---
title: "Controller Input"
description: "Read the D-pad and buttons — make your game interactive."
pubDate: 2026-01-10
game: 1
gameName: "Neon Nexus"
unit: 7
totalUnits: 64
system: "Nintendo Entertainment System"
tags: ["assembly", "6502", "input", "controller", "joypad"]
prevLesson: "/nintendo-entertainment-system/assembly/game-01-neon-nexus/unit-06"
nextLesson: "/nintendo-entertainment-system/assembly/game-01-neon-nexus/unit-08"
layout: "../../../../layouts/UnitLayout.astro"
---

import CodeFromFile from "@components/CodeFromFile.astro";

## What You're Building

The arena exists. The player is visible. But nothing moves.

By the end of this unit, you'll have:

- Controller reading code
- Player movement with D-pad input
- Boundary checking to stay inside the arena
- Your first interactive NES program

The player sprite will move when you press the D-pad — real interactivity.

## The Controller Interface

The NES controller has 8 buttons: A, B, Select, Start, Up, Down, Left, Right.

Reading them requires talking to the joypad register:

<CodeFromFile src="nintendo-entertainment-system/game-01-neon-nexus/unit-07/snippets/01-joypad-register.asm" />

The controller doesn't give you all buttons at once. You have to read them one at a time through a serial interface.

## The Strobe Protocol

Before reading buttons, you must **strobe** the controller. This latches the current button state:

<CodeFromFile src="nintendo-entertainment-system/game-01-neon-nexus/unit-07/snippets/02-strobe-controller.asm" />

Writing 1 then 0 tells the controller to capture the current state of all buttons. Without this, the buttons would continuously shift through.

## Reading All Buttons

After the strobe, read $4016 eight times. Each read returns one button's state in bit 0:

<CodeFromFile src="nintendo-entertainment-system/game-01-neon-nexus/unit-07/snippets/03-read-buttons.asm" />

The `LSR` instruction shifts bit 0 into the carry flag. The `ROL` instruction rotates the carry into our `buttons` variable. After 8 iterations, all buttons are packed into one byte.

## Checking Individual Buttons

With all buttons in one byte, use `AND` to test specific buttons:

<CodeFromFile src="nintendo-entertainment-system/game-01-neon-nexus/unit-07/snippets/04-check-button.asm" />

The `AND` instruction isolates just the bit we care about. If that bit is 0 (not pressed), the zero flag is set and `BEQ` branches.

## Movement with Boundaries

We want the player to move but stay within the arena border:

<CodeFromFile src="nintendo-entertainment-system/game-01-neon-nexus/unit-07/snippets/05-movement-with-bounds.asm" />

Each direction check:
1. Tests the corresponding button
2. Compares position against boundary
3. Only moves if within bounds
4. Updates both the variable and the sprite

## The Game Loop

The main loop now has a purpose:

```asm
main_loop:
    lda #$00
    sta nmi_ready
@wait_for_nmi:
    lda nmi_ready
    beq @wait_for_nmi

    jsr read_controller     ; Read input
    jsr update_player       ; Move based on input

    jmp main_loop
```

Every frame:
1. Wait for VBlank (NMI)
2. Read the controller
3. Update the player position
4. Repeat

## The Complete Code

Here's our program with controller input:

<CodeFromFile src="nintendo-entertainment-system/game-01-neon-nexus/unit-07/nexus.asm" />

## Build It. Run It.

```bash
ca65 nexus.asm -o nexus.o
ld65 -C nes.cfg nexus.o -o nexus.nes
fceux nexus.nes
```

Press the arrow keys (or D-pad on your controller) to move the player:

![Player in bordered arena, ready for input](/images/nintendo-entertainment-system/game-01-neon-nexus/unit-07/screenshot.png)

The player responds to input! Move around the arena — you'll stay within the blue border.

## Why Serial Reading?

The NES uses a serial protocol for controllers because it minimises wiring. Each controller only needs a few pins:
- Power (+5V)
- Ground
- Data (serial out)
- Latch (strobe)
- Clock (generated by CPU reads)

This was cheaper than parallel interfaces that would need 8+ data lines per controller.

## What You've Learnt

- **Joypad register**: $4016 for player 1
- **Strobe protocol**: Write 1, then 0 to latch buttons
- **Serial reading**: 8 reads to get all buttons
- **Bit packing**: LSR/ROL to collect bits into a byte
- **Button testing**: AND with mask, then BEQ/BNE
- **Boundary checking**: Compare before moving

## Next Unit

The player moves, but there's nothing to interact with. No challenge, no goal.

In Unit 8, we'll add enemies — sprites that move on their own. The arena becomes dangerous.
