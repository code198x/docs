---
title: "Collision Detection"
description: "Make enemies dangerous — detect when sprites overlap."
pubDate: 2026-01-10
game: 1
gameName: "Neon Nexus"
unit: 9
totalUnits: 64
system: "Nintendo Entertainment System"
tags: ["assembly", "6502", "collision", "game-state"]
prevLesson: "/nintendo-entertainment-system/assembly/game-01-neon-nexus/unit-08"
nextLesson: "/nintendo-entertainment-system/assembly/game-01-neon-nexus/unit-10"
layout: "../../../../layouts/UnitLayout.astro"
---

import CodeFromFile from "@components/CodeFromFile.astro";

## What You're Building

Enemies move. But they can't hurt you yet — you pass right through them.

By the end of this unit, you'll have:

- Bounding box collision detection
- Game over when player touches an enemy
- Press Start to restart after dying
- The game's first real challenge

The enemies become dangerous.

## Bounding Box Collision

The simplest collision detection uses **bounding boxes** — invisible rectangles around each sprite. Two objects collide if their boxes overlap.

<CodeFromFile src="nintendo-entertainment-system/game-01-neon-nexus/unit-09/snippets/01-bounding-box.asm" />

For 8×8 sprites, a hitbox of 7 pixels means they must nearly touch to collide. This feels fair — glancing blows don't count.

## Calculating Distance

To check overlap, we need the distance between sprites. The formula is `|player_x - enemy_x|` — the absolute value of the difference.

<CodeFromFile src="nintendo-entertainment-system/game-01-neon-nexus/unit-09/snippets/02-absolute-value.asm" />

The subtraction can be negative if the enemy is to the right. We detect this with the carry flag and negate if needed.

## The Collision Loop

Check the player against each enemy:

<CodeFromFile src="nintendo-entertainment-system/game-01-neon-nexus/unit-09/snippets/03-collision-loop.asm" />

We check X first — if X distance is too large, skip to next enemy. Only if X is close enough do we bother checking Y. This optimisation matters when checking many objects.

## Game Over State

When collision is detected, we set a flag and change behaviour:

<CodeFromFile src="nintendo-entertainment-system/game-01-neon-nexus/unit-09/snippets/04-game-over-state.asm" />

In game over state:
- Player doesn't move
- Enemies don't move
- Screen freezes
- Only Start button is checked

## Restarting

When Start is pressed after game over, reset everything:

<CodeFromFile src="nintendo-entertainment-system/game-01-neon-nexus/unit-09/snippets/05-restart-game.asm" />

Player returns to centre, enemies reset to starting positions, and gameplay resumes.

## The Complete Code

Here's our program with collision detection:

<CodeFromFile src="nintendo-entertainment-system/game-01-neon-nexus/unit-09/nexus.asm" />

## Build It. Run It.

```bash
ca65 nexus.asm -o nexus.o
ld65 -C nes.cfg nexus.o -o nexus.nes
fceux nexus.nes
```

You should see the player and red enemies:

![Player and enemies with collision](/images/nintendo-entertainment-system/game-01-neon-nexus/unit-09/screenshot.png)

Now the enemies are dangerous! Try to dodge them — when you touch one, the game freezes. Press Start to try again.

The enemies are now red (using sprite palette 1) to look more threatening than the green enemies in Unit 8.

## Why Bounding Boxes?

Bounding box collision is:
- **Fast**: Just compare coordinates
- **Simple**: Works with any sprite shape
- **Good enough**: Players rarely notice imprecision

More complex games use pixel-perfect collision, but bounding boxes handle most cases. Many classic NES games used exactly this approach.

## What You've Learnt

- **Bounding box collision**: Compare coordinates within a tolerance
- **Absolute distance**: Use EOR/ADC to negate negative results
- **Early exit**: Skip remaining checks when collision found
- **Game state**: Change behaviour based on flags
- **Restart logic**: Reset all variables to initial values

## Next Unit

The game has danger. But where's the reward?

In Unit 10, we'll add collectible items — something to chase besides survival. Points, scoring, and a reason to keep playing.
