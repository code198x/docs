---
title: "The Nametable"
description: "Fill the background with tiles — the 32×30 grid that defines your game world."
pubDate: 2026-01-10
game: 1
gameName: "Neon Nexus"
unit: 6
totalUnits: 64
system: "Nintendo Entertainment System"
tags: ["assembly", "6502", "ppu", "nametable", "background", "graphics"]
prevLesson: "/nintendo-entertainment-system/assembly/game-01-neon-nexus/unit-05"
nextLesson: "/nintendo-entertainment-system/assembly/game-01-neon-nexus/unit-07"
layout: "../../../../layouts/UnitLayout.astro"
---

import CodeFromFile from "@components/CodeFromFile.astro";

## What You're Building

Sprites work. Now we need a world for them to exist in.

By the end of this unit, you'll have:

- Background tiles filling the screen
- A border pattern around the play area
- Understanding of nametable addressing
- Attribute table controlling background palettes

The screen will show a bordered arena — the foundation of your game world.

## The Nametable

The NES background is a **32×30 grid of tile indices** called the nametable. Each byte in the nametable references a tile from the pattern table.

- **Nametable 0**: $2000-$23BF (960 bytes)
- **Attribute table**: $23C0-$23FF (64 bytes)

The PPU reads this grid during rendering, looking up each tile index in the pattern table and drawing the corresponding 8×8 graphic.

## Writing to the Nametable

To write tile indices, set the PPU address and write data:

<CodeFromFile src="nintendo-entertainment-system/game-01-neon-nexus/unit-06/snippets/01-nametable-address.asm" />

The PPU address auto-increments after each write. With PPUCTRL bit 2 clear, it increments by 1 (moving right). This lets you fill rows efficiently with loops.

## Filling a Row

Each row is 32 tiles. A simple loop fills an entire row:

<CodeFromFile src="nintendo-entertainment-system/game-01-neon-nexus/unit-06/snippets/02-fill-row.asm" />

## Creating a Border

For a bordered play area, we need:
- **Top row**: 32 solid tiles
- **Middle rows**: 1 solid, 30 empty, 1 solid (×28 rows)
- **Bottom row**: 32 solid tiles

<CodeFromFile src="nintendo-entertainment-system/game-01-neon-nexus/unit-06/snippets/03-middle-rows.asm" />

The nested loops write exactly 32 tiles per row, filling the entire visible area with our border pattern.

## Nametable Addressing

To write to a specific position, calculate the address:

<CodeFromFile src="nintendo-entertainment-system/game-01-neon-nexus/unit-06/snippets/04-nametable-math.asm" />

In practice, sequential writes with auto-increment handle most background updates. Address calculations are mainly needed when modifying specific tiles during gameplay.

## The Attribute Table

The attribute table assigns palettes to background tiles. Each byte covers a 4×4 tile area:

<CodeFromFile src="nintendo-entertainment-system/game-01-neon-nexus/unit-06/snippets/05-attribute-table.asm" />

This coarse granularity is why NES backgrounds often have a blocky colour look — you can't assign different palettes to adjacent tiles.

## The Complete Code

Here's our program with a bordered background:

<CodeFromFile src="nintendo-entertainment-system/game-01-neon-nexus/unit-06/nexus.asm" />

## Build It. Run It.

```bash
ca65 nexus.asm -o nexus.o
ld65 -C nes.cfg nexus.o -o nexus.nes
fceux nexus.nes
```

You should see a bordered arena with the player sprite:

![Bordered arena with player sprite](/images/nintendo-entertainment-system/game-01-neon-nexus/unit-06/screenshot.png)

The blue border is created by tile 2 (solid block) using palette 0 (blues). The interior is tile 0 (empty), showing the background colour. The player sprite sits in the centre, ready for action.

## Nametable Layout

The full nametable memory map:

| Address | Purpose |
|---------|---------|
| $2000-$23BF | Nametable 0 (960 tiles) |
| $23C0-$23FF | Attribute table 0 (64 bytes) |
| $2400-$27BF | Nametable 1 (960 tiles) |
| $27C0-$27FF | Attribute table 1 (64 bytes) |

The NES has enough VRAM for two nametables. With vertical mirroring (our current setup), nametables 0 and 1 are side-by-side — useful for horizontal scrolling games.

## What You've Learnt

- **Nametable**: 32×30 grid of tile indices at $2000
- **Sequential writes**: Auto-increment fills rows efficiently
- **Address calculation**: $2000 + (row × 32) + column
- **Attribute table**: 64 bytes at $23C0, each covering 4×4 tiles
- **Palette assignment**: 2 bits per quadrant in attribute bytes
- **Mirroring**: Determines how nametables are arranged

## Next Unit

The arena exists. The player is visible. But nothing moves yet.

In Unit 7, we'll read the controller — detecting button presses to control the player. You'll finally have interactivity.
