---
title: "PPU Fundamentals"
description: "Understand the NES Picture Processing Unit — the custom chip that creates all the graphics."
pubDate: 2026-01-10
game: 1
gameName: "Neon Nexus"
unit: 2
totalUnits: 64
system: "Nintendo Entertainment System"
tags: ["assembly", "6502", "ppu", "graphics", "tiles", "nametable"]
prevLesson: "/nintendo-entertainment-system/assembly/game-01-neon-nexus/unit-01"
nextLesson: "/nintendo-entertainment-system/assembly/game-01-neon-nexus/unit-03"
layout: "../../../../layouts/UnitLayout.astro"
---

import CodeFromFile from "@components/CodeFromFile.astro";

## What You're Learning

Before we can display anything, you need to understand **how** the NES displays graphics. The PPU (Picture Processing Unit) is a custom chip with its own memory, its own rules, and its own quirks.

By the end of this unit, you'll understand:

- How tile-based graphics work
- The PPU's memory layout
- Pattern tables (where tile graphics live)
- Nametables (the screen layout)
- Attribute tables (colour assignment)
- Palettes (the NES colour system)

The screen stays blank for now — we're building knowledge, not pixels. But this knowledge is essential for everything that follows.

## The PPU: A Separate World

The PPU is not just "the graphics chip". It's practically a separate computer:

- **Own memory**: 16KB address space, separate from the CPU
- **Own timing**: Runs independently, drawing the screen line by line
- **Own rules**: The CPU can only talk to it through 8 registers

Think of it like this: the CPU is the game logic brain, the PPU is the TV artist. They communicate through a narrow channel (those 8 registers), and timing matters enormously.

## PPU Registers

We access the PPU through memory-mapped registers at $2000-$2007:

<CodeFromFile src="nintendo-entertainment-system/game-01-neon-nexus/unit-02/snippets/01-ppu-registers.asm" />

Each register has a specific purpose:

| Register | Address | Purpose |
|----------|---------|---------|
| PPUCTRL | $2000 | Main control (NMI enable, pattern table select, etc.) |
| PPUMASK | $2001 | Rendering control (show sprites/background, colour effects) |
| PPUSTATUS | $2002 | Status flags (VBlank, sprite 0 hit, overflow) |
| OAMADDR | $2003 | Sprite memory address |
| OAMDATA | $2004 | Sprite memory data |
| PPUSCROLL | $2005 | Scroll position (write twice: X then Y) |
| PPUADDR | $2006 | VRAM address (write twice: high then low) |
| PPUDATA | $2007 | VRAM data read/write |

## PPU Memory Map

The PPU has its own 16KB address space. Here's what lives where:

<CodeFromFile src="nintendo-entertainment-system/game-01-neon-nexus/unit-02/snippets/02-ppu-addresses.asm" />

| Address Range | Size | Contents |
|---------------|------|----------|
| $0000-$0FFF | 4KB | Pattern Table 0 (background tiles) |
| $1000-$1FFF | 4KB | Pattern Table 1 (sprite tiles) |
| $2000-$23FF | 1KB | Nametable 0 |
| $2400-$27FF | 1KB | Nametable 1 |
| $2800-$2FFF | 2KB | Nametable mirrors (depends on cartridge) |
| $3000-$3EFF | — | Mirror of $2000-$2EFF |
| $3F00-$3F1F | 32B | Palettes |
| $3F20-$3FFF | — | Palette mirrors |

The most important regions:
- **Pattern tables**: Tile graphics data (from CHR ROM)
- **Nametables**: Which tile goes where on screen
- **Palettes**: What colours to use

## Pattern Tables: Tile Graphics

NES graphics are built from 8×8 pixel **tiles**. All tile graphics are stored in the pattern tables.

Each tile uses 16 bytes — 8 bytes for the "low" bit plane, 8 bytes for the "high" bit plane. Combined, they give 2 bits per pixel (4 colours):

<CodeFromFile src="nintendo-entertainment-system/game-01-neon-nexus/unit-02/snippets/03-pattern-table-format.asm" />

The colour value for each pixel is:
- **0**: Transparent (or background colour)
- **1**: Colour 1 from the palette
- **2**: Colour 2 from the palette
- **3**: Colour 3 from the palette

With 4KB per pattern table and 16 bytes per tile, you get **256 tiles** per table. That's your graphics vocabulary — every image on screen is built from these 256 building blocks.

## Nametables: Screen Layout

The nametable is a 32×30 grid of tile numbers. Each byte references a tile from the pattern table:

<CodeFromFile src="nintendo-entertainment-system/game-01-neon-nexus/unit-02/snippets/04-nametable-structure.asm" />

The screen is:
- **32 tiles wide** × 8 pixels = 256 pixels
- **30 tiles tall** × 8 pixels = 240 pixels

That's 960 bytes for the tile references. The remaining 64 bytes are the attribute table.

When the PPU draws the screen, it reads the nametable row by row, looks up each tile number in the pattern table, and renders the pixels.

## Attribute Tables: Palette Zones

Colour on the NES is complicated. You can't assign a palette to each individual tile — that would need too much memory. Instead, the attribute table divides the screen into 2×2 tile groups, and each group shares a palette.

<CodeFromFile src="nintendo-entertainment-system/game-01-neon-nexus/unit-02/snippets/05-attribute-table.asm" />

Each byte controls a 4×4 tile area (16 tiles total), divided into four 2×2 quadrants. The 2-bit value for each quadrant selects one of four background palettes.

This constraint is why NES games have that distinctive "blocky colour" look — adjacent tiles often share colours because they're in the same attribute zone.

## Palettes: The NES Colours

The NES has a fixed master palette of 64 colours (though some are duplicates). You select 32 of these for each frame:

<CodeFromFile src="nintendo-entertainment-system/game-01-neon-nexus/unit-02/snippets/06-palette-layout.asm" />

The palette structure:
- **16 bytes** for background (4 palettes × 4 colours)
- **16 bytes** for sprites (4 palettes × 4 colours)

But there's a catch: colour 0 of every palette is transparent, and they all share the same "background colour" at $3F00. So you really get 3 unique colours per palette, plus the shared background.

## Accessing PPU Memory

The CPU can't directly read or write PPU memory. You access it through PPUADDR and PPUDATA:

<CodeFromFile src="nintendo-entertainment-system/game-01-neon-nexus/unit-02/snippets/07-ppu-access.asm" />

The process:
1. Read PPUSTATUS to reset the address latch
2. Write the high byte of the address to PPUADDR
3. Write the low byte to PPUADDR
4. Read or write PPUDATA (address auto-increments)

**Critical rule**: Only access PPU memory during VBlank! If you write while the PPU is drawing, you'll corrupt the display.

## The Complete Code

Here's our program with expanded PPU definitions:

<CodeFromFile src="nintendo-entertainment-system/game-01-neon-nexus/unit-02/nexus.asm" />

The screen is still blank because:
- Rendering is disabled (PPUMASK = 0)
- No palettes loaded
- No tile graphics defined
- No nametable data

But now you understand *why* it's blank, and *what* you need to change.

## Build It. Run It.

```bash
ca65 nexus.asm -o nexus.o
ld65 -C nes.cfg nexus.o -o nexus.nes
fceux nexus.nes
```

Same blank grey screen:

![A blank screen - PPU ready but no graphics defined](/images/nintendo-entertainment-system/game-01-neon-nexus/unit-02/screenshot.png)

The PPU is ready. It's waiting for you to:
1. Load palette colours
2. Define tile graphics
3. Fill the nametable
4. Enable rendering

## What You've Learnt

- **PPU architecture**: A separate chip with its own memory
- **Pattern tables**: 8×8 tiles stored as two bit planes
- **Nametables**: 32×30 grid defining screen layout
- **Attribute tables**: 2×2 tile groups sharing palettes
- **Palettes**: 4 background + 4 sprite palettes
- **PPU access**: Through PPUADDR/PPUDATA during VBlank only

## The Big Picture

Here's how it all fits together:

```
Pattern Table          Nametable              Screen
(tile graphics)        (tile numbers)         (pixels)
┌──┬──┬──┬──┐         ┌──┬──┬──┬──┐         ┌────────────┐
│00│01│02│03│         │01│02│01│02│  ──▶    │████░░██░░░░│
├──┼──┼──┼──┤         ├──┼──┼──┼──┤         │░░░░████░░░░│
│04│05│06│07│         │03│01│03│01│         │██░░░░░░██░░│
├──┼──┼──┼──┤         ├──┼──┼──┼──┤         │░░██░░░░░░██│
│..│..│..│..│         │..│..│..│..│         │............│
└──┴──┴──┴──┘         └──┴──┴──┴──┘         └────────────┘
(256 tiles)           (32×30 = 960 bytes)    (256×240 px)

                      Attribute Table
                      (palette zones)
                      ┌────┬────┐
                      │P0P1│P2P3│  ──▶  Colours!
                      ├────┼────┤
                      │P0P1│P2P3│
                      └────┴────┘
```

The PPU reads the nametable, looks up tiles in the pattern table, applies colours from the attribute table and palettes, and draws pixels to the screen. 60 times per second. Automatically.

Your job is to set up the data. The PPU does the rest.

## Next Unit

We understand the PPU. But we're not talking to it yet.

In Unit 3, we'll set up proper VBlank timing with NMI interrupts — the foundation for all PPU updates. You'll learn when it's safe to write to PPU memory and how to synchronise your game with the display.
