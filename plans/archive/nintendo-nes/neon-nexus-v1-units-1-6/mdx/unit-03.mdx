---
title: "VBlank and NMI"
description: "Set up proper frame timing with the Non-Maskable Interrupt — the heartbeat of every NES game."
pubDate: 2026-01-10
game: 1
gameName: "Neon Nexus"
unit: 3
totalUnits: 64
system: "Nintendo Entertainment System"
tags: ["assembly", "6502", "nmi", "vblank", "timing", "interrupts"]
prevLesson: "/nintendo-entertainment-system/assembly/game-01-neon-nexus/unit-02"
nextLesson: "/nintendo-entertainment-system/assembly/game-01-neon-nexus/unit-04"
layout: "../../../../layouts/UnitLayout.astro"
---

import CodeFromFile from "@components/CodeFromFile.astro";

## What You're Building

The PPU draws the screen 60 times per second. Your code needs to dance to that rhythm.

By the end of this unit, you'll have:

- A proper NMI handler that fires every frame
- A frame-synchronised main loop
- Understanding of when it's safe to update PPU memory
- The timing foundation every NES game needs

The screen stays blank — but now your code runs at a stable 60 FPS, perfectly synchronised with the display.

## The VBlank Period

The NES screen is 256×240 pixels. The PPU draws it top to bottom, one line at a time, 60 times per second (NTSC) or 50 times per second (PAL).

After drawing line 239 (the last visible line), the PPU enters **VBlank** — a brief pause before starting the next frame. During VBlank:

- The electron beam returns to the top of the screen
- The PPU isn't drawing anything
- **This is the ONLY safe time to write to PPU memory**

VBlank lasts about 2273 CPU cycles — roughly 20 scanlines worth. Not long, but enough to update palettes, scroll position, and transfer sprite data.

## The Timing Problem

Without proper timing, your game runs as fast as the CPU can execute instructions — thousands of frames per second. That's useless for a game:

- Movement becomes a blur
- Animation is invisible
- The game is unplayable

We need a way to:
1. Know when VBlank starts
2. Do PPU updates during VBlank
3. Wait until the next VBlank before processing the next frame

## The NMI Solution

The NES has a special interrupt called **NMI** (Non-Maskable Interrupt). Unlike regular interrupts (IRQ), you can't disable NMI with the `sei` instruction — it's "non-maskable".

When VBlank begins, the PPU can trigger an NMI. The CPU:
1. Stops whatever it was doing
2. Pushes the program counter and status register to the stack
3. Jumps to the address stored at $FFFA-$FFFB
4. Executes your NMI handler
5. Returns with `rti` and continues where it left off

This happens automatically, 60 times per second — the heartbeat of your game.

## Enabling NMI

NMI is disabled by default. To enable it, set bit 7 of PPUCTRL:

<CodeFromFile src="nintendo-entertainment-system/game-01-neon-nexus/unit-03/snippets/02-enable-nmi.asm" />

Once enabled, the NMI fires at the start of every VBlank period.

## Variables for Timing

We need two variables in zero page:

<CodeFromFile src="nintendo-entertainment-system/game-01-neon-nexus/unit-03/snippets/01-variables.asm" />

- **nmi_ready**: Set by NMI, cleared by main loop. Signals "VBlank has occurred".
- **frame_counter**: Counts frames. Useful for timing and animation.

## The Main Loop

The main loop waits for VBlank, then processes one frame of game logic:

<CodeFromFile src="nintendo-entertainment-system/game-01-neon-nexus/unit-03/snippets/03-main-loop.asm" />

The pattern:
1. Clear the `nmi_ready` flag
2. Spin in a tight loop until NMI sets the flag
3. Process game logic (input, state updates, etc.)
4. Loop back to step 1

This guarantees your game logic runs exactly once per frame — no faster, no slower.

## The NMI Handler

The NMI handler runs at the start of every VBlank:

<CodeFromFile src="nintendo-entertainment-system/game-01-neon-nexus/unit-03/snippets/04-nmi-handler.asm" />

Critical points:
- **Preserve registers**: The NMI can interrupt the main loop at any point. If we modify A, X, or Y without saving them, we corrupt the main loop's state.
- **Keep it fast**: We only have ~2273 cycles. Do essential PPU updates here.
- **Signal the main loop**: Set `nmi_ready` so the main loop knows to proceed.

## Register Preservation

Why do we push and pop registers? Consider this scenario:

```
Main loop:            NMI fires here!
  lda #$42            ↓
  ; doing something   ──────────────────
  sta somewhere       NMI handler runs
                      Changes A to $01
                      Returns
                      ──────────────────
  ; A was $42, now it's $01!
  ; Our calculation is ruined!
```

The solution:

<CodeFromFile src="nintendo-entertainment-system/game-01-neon-nexus/unit-03/snippets/05-register-preservation.asm" />

Push at the start, pop at the end, in reverse order (stack is LIFO — Last In, First Out).

## The Complete Code

Here's our program with proper NMI timing:

<CodeFromFile src="nintendo-entertainment-system/game-01-neon-nexus/unit-03/nexus.asm" />

## Build It. Run It.

```bash
ca65 nexus.asm -o nexus.o
ld65 -C nes.cfg nexus.o -o nexus.nes
fceux nexus.nes
```

Same blank screen:

![A blank screen - but now running at stable 60 FPS](/images/nintendo-entertainment-system/game-01-neon-nexus/unit-03/screenshot.png)

It looks identical to Unit 2 — but internally, everything has changed. The NMI is firing 60 times per second. The main loop is synchronised to the frame rate. The foundation is ready.

## What's Different?

In Unit 2, the main loop was:
```asm
forever:
    jmp forever
```

Now it's:
```asm
main_loop:
    lda #$00
    sta nmi_ready
@wait_for_nmi:
    lda nmi_ready
    beq @wait_for_nmi
    ; ... game logic here ...
    jmp main_loop
```

The old loop spun as fast as possible. The new loop waits for VBlank, processes one frame, then waits again. This is the structure every NES game uses.

## What You've Learnt

- **VBlank**: The ~2273 cycle window when PPU updates are safe
- **NMI**: Non-Maskable Interrupt — fires at VBlank start when enabled
- **PPUCTRL bit 7**: Enables NMI generation
- **Frame synchronisation**: Wait for NMI, process, wait again
- **Register preservation**: Push/pop A, X, Y to protect main loop state
- **rti**: Return from Interrupt — restores PC and status, continues execution

## The Frame Structure

Here's how a typical NES game frame works:

```
┌──────────────────────────────────────────────────┐
│ VBlank starts                                    │
│ ┌──────────────────────────────────────────────┐ │
│ │ NMI Handler (~2273 cycles available)         │ │
│ │ • Update palettes                            │ │
│ │ • Update nametable                           │ │
│ │ • DMA sprites                                │ │
│ │ • Set scroll position                        │ │
│ │ • Set nmi_ready flag                         │ │
│ └──────────────────────────────────────────────┘ │
│ VBlank ends, rendering begins                    │
│ ┌──────────────────────────────────────────────┐ │
│ │ Main Loop (rest of frame)                    │ │
│ │ • See nmi_ready, clear it                    │ │
│ │ • Read controller                            │ │
│ │ • Update game state                          │ │
│ │ • Prepare next frame's data                  │ │
│ │ • Wait for next NMI...                       │ │
│ └──────────────────────────────────────────────┘ │
└──────────────────────────────────────────────────┘
```

VBlank is short — use it wisely for PPU updates only. Do your heavy processing (AI, physics, etc.) in the main loop when the PPU is busy drawing.

## Next Unit

The timing is solid. Now let's use it.

In Unit 4, we'll load palettes and see colour on screen for the first time. The PPU will finally have something to display.
