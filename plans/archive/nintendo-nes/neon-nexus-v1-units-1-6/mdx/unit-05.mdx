---
title: "Pattern Tables"
description: "Design 8×8 pixel tiles — the building blocks of all NES graphics."
pubDate: 2026-01-10
game: 1
gameName: "Neon Nexus"
unit: 5
totalUnits: 64
system: "Nintendo Entertainment System"
tags: ["assembly", "6502", "ppu", "tiles", "chr-rom", "graphics"]
prevLesson: "/nintendo-entertainment-system/assembly/game-01-neon-nexus/unit-04"
nextLesson: "/nintendo-entertainment-system/assembly/game-01-neon-nexus/unit-06"
layout: "../../../../layouts/UnitLayout.astro"
---

import CodeFromFile from "@components/CodeFromFile.astro";

## What You're Building

Colours work. Now we need shapes.

By the end of this unit, you'll have:

- Custom tile graphics defined in CHR-ROM
- Understanding of the 2-bit planar format
- Multiple tiles with different patterns
- Sprites displaying your tiles on screen

The screen will show actual graphics — your first real NES artwork.

## The Tile Format

Every graphic on the NES is built from 8×8 pixel tiles. Each pixel can be one of 4 colours (selected from a palette).

To store 4 colours, you need 2 bits per pixel. With 64 pixels per tile (8×8), that's 128 bits = 16 bytes per tile.

<CodeFromFile src="nintendo-entertainment-system/game-01-neon-nexus/unit-05/snippets/01-tile-format.asm" />

The clever part: the NES doesn't store 2 bits per pixel sequentially. Instead, it uses **two separate bit planes**:

- **Low plane** (8 bytes): Bit 0 of each pixel
- **High plane** (8 bytes): Bit 1 of each pixel

To get a pixel's colour, you combine both planes:

| Low Plane | High Plane | Colour |
|-----------|------------|--------|
| 0 | 0 | 0 (transparent for sprites) |
| 1 | 0 | 1 |
| 0 | 1 | 2 |
| 1 | 1 | 3 |

## Creating a Tile: The Player Ship

Let's design a simple arrow/ship shape pointing upward:

```
Row 0:  . . . X X . . .
Row 1:  . . X X X X . .
Row 2:  . X X X X X X .
Row 3:  X X X X X X X X
Row 4:  X X X X X X X X
Row 5:  . . X . . X . .
Row 6:  . . X . . X . .
Row 7:  . X X . . X X .
```

Converting to binary (X = 1, . = 0):

<CodeFromFile src="nintendo-entertainment-system/game-01-neon-nexus/unit-05/snippets/02-player-tile.asm" />

With the high plane all zeros, every "on" pixel is colour 1. This simple approach gives us a solid single-colour shape.

## A Solid Block

The simplest tile — every pixel set to colour 3:

<CodeFromFile src="nintendo-entertainment-system/game-01-neon-nexus/unit-05/snippets/03-solid-tile.asm" />

Both planes are $FF (all 1s), so every pixel is colour 3 — the brightest colour in the palette.

## Multi-Colour Tiles

To use all 4 colours, you set different combinations in the two planes:

<CodeFromFile src="nintendo-entertainment-system/game-01-neon-nexus/unit-05/snippets/04-checkerboard-tile.asm" />

The alternating patterns in the low and high planes create a checkerboard that cycles through colours 1 and 2.

## Displaying Tiles with Sprites

To see our tiles, we'll use sprites. Each sprite references a tile by index:

<CodeFromFile src="nintendo-entertainment-system/game-01-neon-nexus/unit-05/snippets/05-sprite-setup.asm" />

The sprite's attribute byte includes the palette number (bits 0-1), so we can colour each sprite differently using the same tile.

## OAM DMA Transfer

To get sprites on screen, we need to copy sprite data to the PPU every frame. This happens in the NMI handler via **DMA** (Direct Memory Access):

```asm
; In the NMI handler:
    lda #$00
    sta OAMADDR             ; Start at OAM address 0
    lda #$02                ; High byte of $0200
    sta OAMDMA              ; Trigger DMA transfer
```

Writing to $4014 (OAMDMA) copies 256 bytes from the specified CPU page to PPU OAM. It's fast (~513 CPU cycles) and happens automatically.

## The Complete Code

Here's our program with tile graphics and sprite display:

<CodeFromFile src="nintendo-entertainment-system/game-01-neon-nexus/unit-05/nexus.asm" />

## Build It. Run It.

```bash
ca65 nexus.asm -o nexus.o
ld65 -C nes.cfg nexus.o -o nexus.nes
fceux nexus.nes
```

You should see four sprites in a row:

![Four sprites showing different tile patterns](/images/nintendo-entertainment-system/game-01-neon-nexus/unit-05/screenshot.png)

From left to right:
- **Player ship** (white) — tile 1, palette 0
- **Solid block** (green) — tile 2, palette 1
- **Checkerboard** (magenta) — tile 3, palette 2
- **Diagonal** (orange) — tile 4, palette 3

Each sprite uses a different palette, showing how the same tile data can produce different colours.

## The Pattern Table Layout

CHR-ROM is organised as two 4KB pattern tables:

- **Pattern Table 0** ($0000-$0FFF): 256 tiles, typically for backgrounds
- **Pattern Table 1** ($1000-$1FFF): 256 tiles, typically for sprites

PPUCTRL bit 3 selects which pattern table sprites use. By default (bit 3 = 0), sprites use pattern table 0, where our tiles are defined.

With 256 tiles available, you have a vocabulary of shapes to build your game world. Complex graphics are assembled from multiple tiles — a character might be 2×2 tiles (16×16 pixels), a large boss might be 4×4 tiles.

## What You've Learnt

- **Tile format**: 16 bytes per tile (8 low plane + 8 high plane)
- **2-bit colour**: Combine both planes to get values 0-3
- **Pattern tables**: 256 tiles each, 4KB total per table
- **Sprite format**: Y, tile index, attributes, X (4 bytes per sprite)
- **OAM DMA**: Fast transfer via $4014 (OAMDMA)
- **Palette selection**: Sprite attribute bits 0-1 choose palette

## Designing Your Own Tiles

When creating tiles, sketch on graph paper first:

```
  0 1 2 3 4 5 6 7
0 . . . X X . . .   →  %00011000 = $18
1 . . X X X X . .   →  %00111100 = $3C
2 . X X X X X X .   →  %01111110 = $7E
...
```

Then convert each row to binary and hexadecimal. For multi-colour tiles, create separate low and high plane patterns.

## Next Unit

Sprites are working. But the background is still a solid colour.

In Unit 6, we'll write to the nametable — the 32×30 grid that defines the background. You'll fill the screen with tiles and see your game world take shape.
