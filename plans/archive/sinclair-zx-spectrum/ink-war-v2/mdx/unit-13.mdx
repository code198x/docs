---
title: "Game States"
description: "Structure your game with a state machine: title screen, playing, and results. Clean transitions make your game feel professional."
pubDate: 2026-01-09
game: 1
gameName: "Ink War"
unit: 13
totalUnits: 64
system: "Sinclair ZX Spectrum"
tags: ["assembly", "z80", "state-machine", "title-screen", "game-loop"]
prevLesson: "/sinclair-zx-spectrum/assembly/game-01-ink-war/unit-12"
nextLesson: "/sinclair-zx-spectrum/assembly/game-01-ink-war/unit-14"
layout: "../../../../layouts/UnitLayout.astro"
---

import CodeFromFile from "@components/CodeFromFile.astro";
import InlineNote from "../../../../components/units/InlineNote.astro";

## What You're Building

Until now, our game starts playing immediately and ends forever. Real games have structure: a title screen to build anticipation, gameplay, then results with the option to play again.

By the end of this unit, you'll have:

- A state machine with three distinct states
- A title screen showing "INK WAR" and a prompt
- Clean transitions between states
- A game that flows: title → playing → results → title

![Unit 13 Screenshot](/images/sinclair-zx-spectrum/game-01-ink-war/unit-13/screenshot.png)

*The title screen — press any key to begin the battle.*

## The State Machine Pattern

A state machine is one of the most useful patterns in game development. Instead of tangled conditionals, you have:

1. A variable holding the current state
2. A dispatch that routes to the right handler
3. Transition functions that set up each state

<CodeFromFile src="sinclair-zx-spectrum/game-01-ink-war/unit-13/snippets/01-state-constants.asm" />

Three states are all we need: showing the title, playing the game, showing results.

## The Main Loop Dispatch

Every frame, check the current state and call the appropriate handler:

<CodeFromFile src="sinclair-zx-spectrum/game-01-ink-war/unit-13/snippets/02-state-dispatch.asm" />

Each handler is responsible for exactly one frame of logic. The title handler waits for a key. The playing handler processes input and moves. The results handler flashes the border and checks for a key.

<InlineNote>
Notice how the default case goes to title state. Defensive programming — if game_state somehow becomes invalid, we recover gracefully.
</InlineNote>

## State Transitions

Each transition function sets up everything needed for its state:

<CodeFromFile src="sinclair-zx-spectrum/game-01-ink-war/unit-13/snippets/03-state-transitions.asm" />

The key insight: each state function is self-contained. It clears the screen, draws what it needs, and sets all relevant variables. No assumptions about what came before.

## Blocking vs Non-Blocking Input

We need two styles of key detection:

<CodeFromFile src="sinclair-zx-spectrum/game-01-ink-war/unit-13/snippets/04-key-handling.asm" />

The title screen uses `wait_any_key` — it blocks until a key is pressed. We want the player to see the title and consciously choose to start.

The results screen uses `check_any_key` — it returns immediately so the border can keep flashing. The player can watch the celebration as long as they like.

<InlineNote>
Why wait for key release first? Otherwise, if the player is still holding a key from gameplay, we'd immediately skip the title screen.
</InlineNote>

## Resetting for New Games

When starting a new game, we must clear everything:

<CodeFromFile src="sinclair-zx-spectrum/game-01-ink-war/unit-13/snippets/05-reset-game.asm" />

Every variable that affects gameplay gets reset. The board is cleared. Scores return to zero. Player 1 starts. Miss anything here, and you'll have subtle bugs where the second game behaves differently from the first.

## Build It. Run It.

```bash
pasmonext --sna inkwar.asm inkwar.sna
```

Run in your emulator:

1. The title screen appears: "INK WAR" and "PRESS ANY KEY TO START"
2. Press any key — the game board appears
3. Play through a full game
4. When all cells are claimed, the winner is announced
5. The border flashes in the winner's colour
6. Press any key — back to the title screen
7. Play again!

The game now has a complete loop. You can play forever.

## What You've Learnt

- **State machine pattern**: Clean separation of game phases
- **State dispatch**: Routing to handlers based on current state
- **Transition functions**: Self-contained state setup
- **Blocking vs non-blocking input**: Different needs for different states
- **Game reset**: Ensuring each playthrough starts fresh

## The Complete Code

<CodeFromFile src="sinclair-zx-spectrum/game-01-ink-war/unit-13/inkwar.asm" />

## Next Unit

The game loops, but the results are shown on the game board with scores still visible. In Unit 14, we'll create a dedicated results screen that shows the winner prominently, making the end of each game feel like a proper conclusion.
