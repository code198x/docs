---
title: "Keyboard Input"
description: "Read the Spectrum keyboard directly. Detect key presses, handle debouncing, respond to player input."
pubDate: 2026-01-09
game: 1
gameName: "Ink War"
unit: 5
totalUnits: 64
system: "Sinclair ZX Spectrum"
tags: ["assembly", "z80", "input", "keyboard", "ports"]
prevLesson: "/sinclair-zx-spectrum/assembly/game-01-ink-war/unit-04"
nextLesson: "/sinclair-zx-spectrum/assembly/game-01-ink-war/unit-06"
layout: "../../../../layouts/UnitLayout.astro"
---

import CodeFromFile from "@components/CodeFromFile.astro";
import InlineNote from "../../../../components/units/InlineNote.astro";

## What You're Building

A game needs input. In this unit, we read the keyboard directly — no BASIC, no ROM routines, just raw hardware access.

By the end of this unit, you'll have:

- Understanding of the Spectrum keyboard matrix
- Code to read specific keys (Q, A, O, P, Space)
- Debouncing to detect new presses only
- Visual feedback proving your input works

![Unit 5 Screenshot](/images/sinclair-zx-spectrum/game-01-ink-war/unit-05/screenshot.png)

*The screenshot shows the initial state. Run the program and press keys to see the border flash!*

## The Keyboard Matrix

The Spectrum keyboard is organised as a matrix of 8 half-rows, each containing 5 keys. We read them through port $FE:

<CodeFromFile src="sinclair-zx-spectrum/game-01-ink-war/unit-05/snippets/01-keyboard-matrix.asm" />

To read a half-row, we load its address into A and use the `IN` instruction. The result tells us which keys in that row are pressed.

<InlineNote>
The keyboard shares port $FE with the border colour. When reading (IN), it returns keyboard state. When writing (OUT), it sets border colour. Same port, different functions.
</InlineNote>

## Reading a Key

To check if a specific key is pressed:

<CodeFromFile src="sinclair-zx-spectrum/game-01-ink-war/unit-05/snippets/02-read-key.asm" />

The crucial detail: keys are **active low**. A bit value of 0 means the key IS pressed; 1 means it's NOT pressed. This is backwards from intuition, but it's how the hardware works.

## Our Control Keys

Ink War uses the classic Spectrum control scheme:

| Key | Action | Half-row | Bit |
|-----|--------|----------|-----|
| Q | Up | $FB | 0 |
| A | Down | $FD | 0 |
| O | Left | $DF | 1 |
| P | Right | $DF | 0 |
| Space | Claim | $7F | 0 |

<CodeFromFile src="sinclair-zx-spectrum/game-01-ink-war/unit-05/snippets/03-our-controls.asm" />

Notice that O and P share the same half-row ($DF). We read the row once and test different bits.

## The Debouncing Problem

If we check "is Q pressed?" every frame, a single tap triggers dozens of times. The key is held for perhaps 100ms, but we're checking 50 times per second.

We need to detect **new** presses — the moment a key transitions from "not pressed" to "pressed":

<CodeFromFile src="sinclair-zx-spectrum/game-01-ink-war/unit-05/snippets/04-debouncing.asm" />

The trick: compare current state with previous frame. Using `CPL` (complement) and `AND`, we isolate only the bits that are newly set.

## Visual Feedback

During development, visual feedback is invaluable. We flash the border different colours for each key:

<CodeFromFile src="sinclair-zx-spectrum/game-01-ink-war/unit-05/snippets/05-visual-feedback.asm" />

This confirms the input code works before we connect it to game logic. If the border doesn't flash, we know the problem is in our keyboard code, not elsewhere.

## The Main Loop

Our main loop now has structure:

```asm
main_loop:
        halt                ; Wait for vertical blank
        call read_keys      ; Check keyboard
        jr main_loop        ; Repeat forever
```

`HALT` pauses until the next interrupt (vertical blank). This gives us consistent 50Hz timing and prevents the CPU from running flat-out.

## Build It. Run It.

```bash
pasmonext --sna inkwar.asm inkwar.sna
```

Load it in your emulator and press keys:

- **Q** → Red flash
- **A** → Green flash
- **O** → Cyan flash
- **P** → Yellow flash
- **Space** → White flash

Each key should flash *once* per press, not continuously while held.

## What You've Learnt

- **Keyboard matrix**: 8 half-rows, 5 keys each, read via port $FE
- **Active low**: 0 = pressed, 1 = not pressed
- **IN instruction**: Read from hardware port
- **Debouncing**: Compare current and previous state to detect new presses
- **HALT**: Wait for vertical blank, gives consistent timing

## The Complete Code

<CodeFromFile src="sinclair-zx-spectrum/game-01-ink-war/unit-05/inkwar.asm" />

## Next Unit

We can read input. Now we need something to control. In Unit 6, we'll create a cursor that moves around the board — the first truly interactive element of Ink War.
