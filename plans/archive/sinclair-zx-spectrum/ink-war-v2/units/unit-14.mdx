---
title: "Draw the Game Board"
description: "Create the 8×8 Ink War game board using attribute cells—where the display system becomes the gameplay."
pubDate: 2026-01-09
game: 1
gameSlug: "ink-war"
unit: 14
unitSlug: "draw-the-game-board"
totalUnits: 64
tags: ["assembly", "z80", "graphics", "game-board", "attributes"]
prevUnit: "/sinclair-zx-spectrum/assembly/game-01-ink-war/unit-13"
nextUnit: "/sinclair-zx-spectrum/assembly/game-01-ink-war/unit-15"
layout: "../../../../layouts/UnitLayout.astro"
---

import CodeFromFile from "@components/CodeFromFile.astro";

Ink War's board is an 8×8 grid where players claim territory. Each cell is one attribute square—the Spectrum's display system *is* our game board.

## Board Layout

The board sits centred on screen:

| Property | Value |
|----------|-------|
| Board size | 8×8 cells |
| Top row | 8 (of 24) |
| Left column | 12 (of 32) |
| Total cells | 64 |

## Using Constants

Define board properties at the start for easy modification:

```asm
BOARD_TOP    equ 8           ; Start row
BOARD_LEFT   equ 12          ; Start column
BOARD_SIZE   equ 8           ; Grid dimensions
```

EQU creates named constants. Change one value to move the entire board.

## The Complete Board Code

<CodeFromFile src="sinclair-zx-spectrum/game-01-ink-war/unit-14/board.asm" />

![8×8 game board with checkerboard pattern](/images/sinclair-zx-spectrum/game-01-ink-war/unit-14/board.png)

## Calculating Cell Addresses

Each cell's attribute address:

```asm
address = $5800 + (row × 32) + column
```

For the board's top-left cell (row 8, column 12):

```asm
ld hl, $5800 + (BOARD_TOP * 32) + BOARD_LEFT
; HL = $5800 + 256 + 12 = $590C
```

## Drawing the Border

The border frames the board—a 10×10 area surrounding the 8×8 grid:

```asm
; Top border (row 7, columns 11-20)
ld hl, $5800 + ((BOARD_TOP - 1) * 32) + (BOARD_LEFT - 1)
ld b, 10
ld a, BORDER_ATTR
draw_top:
    ld (hl), a
    inc hl
    djnz draw_top
```

## Drawing Board Rows

Nested loops draw the 8×8 grid:

```asm
ld d, BOARD_SIZE         ; Outer loop: 8 rows

draw_rows:
    push hl              ; Save row start
    ld e, BOARD_SIZE     ; Inner loop: 8 columns

draw_cols:
    ld (hl), a           ; Set cell colour
    inc hl
    dec e
    jr nz, draw_cols

    pop hl               ; Restore row start
    ld bc, 32            ; Add 32 to move down one row
    add hl, bc
    dec d
    jr nz, draw_rows
```

## The Checkerboard Pattern

Alternating colours help visualise the grid:

```asm
    ld a, d              ; Row counter
    xor e                ; XOR with column counter
    and 1                ; Keep lowest bit
    jr z, use_light      ; Even = light
    ; Odd = darker
```

XOR creates alternating pattern: when row+column is even, use one colour; when odd, use another.

## Attribute Values

| Name | Binary | Meaning |
|------|--------|---------|
| BORDER_ATTR | %01000000 | Bright black |
| EMPTY_ATTR | %00111000 | White paper |
| GRID_ATTR | %01111000 | Bright white paper |

## Why Checkerboard?

The alternating pattern:
- Shows grid structure clearly
- Helps players see cell boundaries
- Creates visual interest before colours are added
- Confirms our drawing code works correctly

## Nested Loop Structure

```
Outer loop (D = rows):
    Save position
    Inner loop (E = columns):
        Draw cell
        Move right
    Restore position
    Move down
```

PUSH/POP HL preserves the row start address so we can move down correctly.

## What You've Learnt

- **EQU constants** — Named values for easy modification
- **Address calculation** — Converting row/column to memory address
- **Nested loops** — D for rows, E for columns
- **XOR for patterns** — Creating checkerboard effects
- **PUSH/POP in loops** — Preserving addresses across iterations
