---
title: "Screen Memory Layout"
description: "Discover the Spectrum's unusual interleaved screen memory organisation, divided into thirds with non-consecutive row addressing."
pubDate: 2026-01-09
game: 1
gameSlug: "ink-war"
unit: 2
unitSlug: "screen-memory-layout"
totalUnits: 64
tags: ["assembly", "z80", "display", "screen-memory", "memory-layout"]
prevUnit: "/sinclair-zx-spectrum/assembly/game-01-ink-war/unit-01"
nextUnit: "/sinclair-zx-spectrum/assembly/game-01-ink-war/unit-03"
layout: "../../../../layouts/UnitLayout.astro"
---

import CodeFromFile from "@components/CodeFromFile.astro";

The Spectrum's screen memory isn't organised the way you'd expect. Consecutive bytes in memory don't produce consecutive rows on screen. Understanding this quirk is essential for efficient graphics programming.

## The Three Thirds

The 6144 bytes of screen memory are divided into three 2KB sections:

| Memory Range | Size | Screen Rows |
|--------------|------|-------------|
| $4000-$47FF | 2048 bytes | 0-63 (top third) |
| $4800-$4FFF | 2048 bytes | 64-127 (middle third) |
| $5000-$57FF | 2048 bytes | 128-191 (bottom third) |

This program fills each third with a different pattern, making the division visible:

<CodeFromFile src="sinclair-zx-spectrum/game-01-ink-war/unit-02/layout.asm" />

![Three screen thirds with different patterns](/images/sinclair-zx-spectrum/game-01-ink-war/unit-02/layout.png)

## Why Three Thirds?

The division into thirds comes from the Spectrum's display hardware. The ULA (Uncommitted Logic Array) reads screen memory in a specific pattern optimised for the TV signal timing.

Each third contains 64 pixel rows. With 32 bytes per row, that's 2048 bytes per third—exactly 2KB.

## The Interleaving Problem

Within each third, rows aren't stored consecutively either. The first byte of row 0 is at $4000, but the first byte of row 1 isn't at $4020—it's at $4100.

Here's how the top third is organised:

```
$4000: Row 0, scan line 0
$4020: Row 1, scan line 0
$4040: Row 2, scan line 0
...
$40E0: Row 7, scan line 0
$4100: Row 0, scan line 1  ← Jumps back!
$4120: Row 1, scan line 1
...
```

Each character row (8 pixels tall) has its scan lines scattered 256 bytes apart. This is why simple "add 32 to get the next row" doesn't work on the Spectrum.

## Memory Address Breakdown

For any screen address, the bits encode position:

```
Address: 010T TSSS RRRC CCCC

Where:
  010   = Fixed ($4000 base)
  TT    = Third (00=top, 01=middle, 10=bottom)
  SSS   = Scan line within character row (0-7)
  RRR   = Character row within third (0-7)
  CCCCC = Column (0-31)
```

This explains the interleaving: the scan line bits (SSS) are in the high byte, so incrementing the high byte moves down one scan line, not one pixel row.

## Practical Implications

When you need to move down one pixel row:

```asm
; WRONG - just adds 32
    ld bc, 32
    add hl, bc          ; Doesn't account for interleaving!

; CORRECT - handles scan line boundaries
    inc h               ; Move down one scan line
    ld a, h
    and $07             ; Check if we've wrapped
    jr nz, done         ; If not, we're done
    ld a, l
    add a, 32           ; Move to next character row
    ld l, a
    jr c, done          ; If no carry, stay in same third
    ld a, h
    sub 8               ; Adjust high byte
    ld h, a
done:
```

We'll build a proper address calculation routine in Unit 3. For now, understanding why it's needed is the goal.

## The Fill Routine

The `fill_memory` routine demonstrates simple sequential filling:

```asm
fill_memory:
    ld d, a             ; Save pattern
fill_loop:
    ld (hl), d          ; Store byte
    inc hl              ; Next address
    dec bc              ; Decrement counter
    ld a, b
    or c                ; Check if BC = 0
    jr nz, fill_loop    ; Continue if not
    ret
```

This fills consecutive memory addresses, which is perfect for clearing the screen or filling entire thirds—but won't draw consecutive horizontal lines.

## What You've Learnt

- **Three thirds** — Screen memory divides into $4000, $4800, $5000 (2KB each)
- **64 rows per third** — Each third covers 64 pixel rows
- **Interleaved scan lines** — Rows within a character aren't consecutive
- **Address encoding** — Bits encode third, scan line, row, and column
- **High byte increment** — INC H moves down one scan line, not one row
- **Hardware design** — Layout optimised for ULA timing, not programmer convenience
