---
title: "Calculating Screen Addresses"
description: "Build a routine to convert Y coordinates into screen memory addresses, handling the Spectrum's interleaved layout with bit manipulation."
pubDate: 2026-01-09
game: 1
gameSlug: "ink-war"
unit: 3
unitSlug: "calculating-screen-addresses"
totalUnits: 64
tags: ["assembly", "z80", "display", "screen-memory", "bit-manipulation"]
prevUnit: "/sinclair-zx-spectrum/assembly/game-01-ink-war/unit-02"
nextUnit: "/sinclair-zx-spectrum/assembly/game-01-ink-war/unit-04"
layout: "../../../../layouts/UnitLayout.astro"
---

import CodeFromFile from "@components/CodeFromFile.astro";

Drawing at a specific Y coordinate requires calculating the correct memory address. The Spectrum's interleaved layout means this isn't a simple multiplication—it's bit manipulation.

## The Address Formula

A screen address encodes position in its bits:

```
High byte: 010T TSSS
Low byte:  RRRC CCCC

Where:
  010   = Screen base ($40)
  TT    = Third (00=top, 01=middle, 10=bottom)
  SSS   = Scan line within character (0-7)
  RRR   = Character row within third (0-7)
  CCCCC = Column (0-31)
```

The Y coordinate (0-191) contains all the vertical information:
- **Bits 7-6**: Which third (0, 64, or 128)
- **Bits 5-3**: Character row within that third (0-7)
- **Bits 2-0**: Scan line within character (0-7)

## The Complete Routine

This program draws horizontal lines at every 8th row, proving the address calculation works across all three thirds:

<CodeFromFile src="sinclair-zx-spectrum/game-01-ink-war/unit-03/address.asm" />

![Horizontal lines at regular intervals](/images/sinclair-zx-spectrum/game-01-ink-war/unit-03/address.png)

## Breaking Down get_screen_addr

The routine takes Y in register B and returns the screen address in HL.

### Step 1: Build the High Byte

```asm
    ld a, b             ; A = Y coordinate
    and %00000111       ; Keep scan line bits (0-7)
    or %01000000        ; Add screen base ($40)
    ld h, a             ; H = 010? ?SSS (partial)
```

The scan line (bits 2-0 of Y) goes directly into bits 2-0 of the high byte. The `OR $40` sets bit 6, establishing the $4000 base.

### Step 2: Add the Third

```asm
    ld a, b             ; A = Y coordinate again
    and %11000000       ; Keep third bits
    rrca                ; Rotate right 3 times
    rrca
    rrca
    or h                ; Combine with high byte
    ld h, a             ; H complete: 010T TSSS
```

Bits 7-6 of Y (the third selector) need to move to bits 4-3 of the high byte. Three right rotates accomplish this shift.

### Step 3: Build the Low Byte

```asm
    ld a, b             ; A = Y coordinate
    and %00111000       ; Keep char row bits
    rlca                ; Rotate left twice
    rlca
    ld l, a             ; L = RRR0 0000
```

Bits 5-3 of Y (character row) move to bits 7-5 of the low byte. Two left rotates, and the column remains zero.

## Why Bit Manipulation?

The alternative—arithmetic calculation—is slower:

```asm
; Arithmetic approach (slower)
    ld a, b
    and $07             ; Scan line
    ld h, a
    ld a, b
    and $38             ; Char row × 8
    add a, a            ; × 2
    add a, a            ; × 4
    ld l, a
    ; ... more calculations for third
```

Bit manipulation with AND, OR, and rotate is faster because the Z80 executes these in fewer cycles than multiplication.

## The Drawing Loop

Once we have the address, drawing a line is straightforward:

```asm
    ld b, 32            ; 32 bytes per row
    ld a, $ff           ; Solid pixels
fill_row:
    ld (hl), a          ; Write byte
    inc l               ; Next column
    djnz fill_row       ; Repeat 32 times
```

Using `INC L` instead of `INC HL` is safe here because a row never crosses a 256-byte boundary. It's also one byte shorter and four cycles faster.

## Testing the Routine

The program draws lines at Y = 0, 8, 16, 24... up to 184. This tests:

- **All three thirds**: Lines at Y=0 (top), Y=64 (middle start), Y=128 (bottom start)
- **Multiple character rows**: Eight lines per third
- **Scan line 0 of each**: We're drawing at multiples of 8

If any calculation were wrong, lines would appear in the wrong place or wrap incorrectly between thirds.

## Adding Column Support

To address any pixel, add the X column:

```asm
; Extended version with X coordinate in C
get_pixel_addr:
    ; ... same Y calculation ...

    ; Add column to low byte
    ld a, c             ; A = X coordinate
    srl a               ; Divide by 8
    srl a
    srl a
    or l                ; Add to row offset
    ld l, a             ; L = RRRC CCCC
    ret
```

We'll use this extended version in Unit 4 for pixel plotting.

## What You've Learnt

- **Address encoding** — High byte holds third and scan line; low byte holds row and column
- **Bit extraction** — AND masks isolate specific bits from Y coordinate
- **Bit positioning** — RLCA/RRCA rotate bits to their destination positions
- **Efficiency** — Bit operations faster than arithmetic on Z80
- **Safe increments** — INC L works within a row; INC HL needed across rows
- **Testing strategy** — Draw at regular intervals to verify all screen regions
