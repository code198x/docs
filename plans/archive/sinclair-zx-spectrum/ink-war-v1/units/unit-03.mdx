---
title: "Movement"
description: "Navigate the board with Q, A, O, P. Learn keyboard scanning and the main game loop."
pubDate: 2026-01-03
game: 1
gameName: "Ink War"
unit: 3
totalUnits: 16
system: "Sinclair ZX Spectrum"
tags: ["assembly", "z80", "keyboard", "game-loop"]
nextLesson: "/sinclair-zx-spectrum/assembly/game-01-ink-war/unit-04"
layout: "../../../../layouts/UnitLayout.astro"
---

import CodeFromFile from "@components/CodeFromFile.astro";

*Need to catch up? Check out [Unit 2: The Cursor](/sinclair-zx-spectrum/game-01-ink-war/unit-02).*

## What You're Building

The cursor is blinking, but it's stuck in the corner. Time to set it free.

By the end of this unit, you'll have:

- Keyboard input using the classic Spectrum keys: Q (up), A (down), O (left), P (right)
- A proper game loop that runs at a consistent speed
- A cursor that moves around the board, leaving clean cells behind

The game becomes interactive. You can explore the board.

![The cursor moved to a different cell](/images/sinclair-zx-spectrum/game-01-ink-war/unit-03/screenshot.png)

## The Spectrum Keyboard

The Spectrum keyboard is an 8×5 matrix. There's no dedicated keyboard controller — the CPU reads it directly through port $FE.

The keyboard is organised into 8 "half-rows" of 5 keys each. You select which half-row to read by setting the high byte of the port address:

| High Byte | Keys (bit 0 → bit 4) |
|-----------|---------------------|
| $F7 | 1, 2, 3, 4, 5 |
| $FB | Q, W, E, R, T |
| $FD | A, S, D, F, G |
| $FE | Caps, Z, X, C, V |
| $EF | 0, 9, 8, 7, 6 |
| $DF | P, O, I, U, Y |
| $BF | Enter, L, K, J, H |
| $7F | Space, Sym, M, N, B |

To read a key:
1. Load BC with the port address (B = half-row selector, C = $FE)
2. Execute `in a, (c)`
3. Test the appropriate bit — **0 means pressed**, 1 means not pressed

Yes, it's backwards. Pressed keys pull the line low.

## Our Control Scheme

We'll use the classic Spectrum gaming layout:

| Key | Half-row | Bit | Action |
|-----|----------|-----|--------|
| Q | $FB | 0 | Up |
| A | $FD | 0 | Down |
| O | $DF | 1 | Left |
| P | $DF | 0 | Right |

Q and A are on different half-rows. O and P are on the same half-row but different bits.

## Reading a Key

Here's how to check if Q is pressed:

<CodeFromFile src="sinclair-zx-spectrum/game-01-ink-war/unit-03/snippets/01-reading-a-key.asm" lang="asm" />

**`in a, (c)`** — "Input from port." Reads a byte from the I/O port. The Z80 uses BC for the full 16-bit port address. B appears on the upper address lines (which the keyboard matrix uses), C specifies the port ($FE).

**`bit 0, a`** — "Test bit 0 of A." Sets the zero flag if the bit is 0. Since pressed keys read as 0, the zero flag is set when the key is down.

## The Game Loop

Up until now, our program set things up and then sat in `halt` / `jr` forever. Now we need a proper loop that:

1. Waits for the next frame (timing)
2. Reads the keyboard
3. Updates the game state
4. Repeats

<CodeFromFile src="sinclair-zx-spectrum/game-01-ink-war/unit-03/snippets/02-the-game-loop.asm" lang="asm" />

**Why debounce?** Without the delay, the cursor would fly across the board instantly. At 50 frames per second, even a quick tap registers for multiple frames. We only check the keyboard every 8 frames, giving roughly 6 movements per second — fast enough to feel responsive, slow enough to control.

**`halt`** — Waits for the next interrupt. On the Spectrum, the ULA generates an interrupt 50 times per second (or 60 in NTSC regions). This gives us consistent timing without busy-waiting.

## Clearing the Old Cursor

When we move, we need to turn off the FLASH bit at the old position before turning it on at the new position. Otherwise, we'd leave a trail of flashing cells.

We already have `highlight_cursor` which sets bit 7. We need `clear_cursor` which resets bit 7:

<CodeFromFile src="sinclair-zx-spectrum/game-01-ink-war/unit-03/snippets/03-clearing-the-old-cursor.asm" lang="asm" />

**`res 7, a`** — "Reset bit 7 of A to 0." The opposite of `set`. The FLASH bit is cleared, returning the cell to its normal non-blinking state.

## The Keyboard Handler

We check each direction in turn. If a key is pressed and the move is valid (not off the edge), we clear the old cursor, update the position, and highlight the new location:

<CodeFromFile src="sinclair-zx-spectrum/game-01-ink-war/unit-03/snippets/04-the-keyboard-handler.asm" lang="asm" />

We return after the first key detected. This means only one direction per frame — no diagonal movement. That's fine for a grid-based game.

## Movement Routines

Each direction follows the same pattern:
1. Check if we're at the edge (can't move further)
2. Clear the current cursor
3. Update the position variable
4. Highlight the new position

<CodeFromFile src="sinclair-zx-spectrum/game-01-ink-war/unit-03/snippets/05-movement-routines.asm" lang="asm" />

**`or a`** — A quick way to test if A is zero without changing it. Sets the zero flag if A is 0.

**`cp 7`** — "Compare A with 7." Sets the zero flag if equal. We use this to check for the board edge.

**`dec a` / `inc a`** — Decrement or increment A. Moving up means smaller Y, down means larger Y.

## Helper Routine

We need to call `get_cell_addr` frequently, and it expects B=row, C=column. Let's make a helper:

<CodeFromFile src="sinclair-zx-spectrum/game-01-ink-war/unit-03/snippets/06-helper-routine.asm" lang="asm" />

This pattern — load from memory, shuffle into registers, call subroutine — happens constantly. Wrapping it in a helper keeps the movement routines cleaner.

## Enabling Interrupts

One thing we've been ignoring: interrupts need to be enabled for `halt` to work. Add this near the start of your program:

<CodeFromFile src="sinclair-zx-spectrum/game-01-ink-war/unit-03/snippets/07-enabling-interrupts.asm" lang="asm" />

**`im 1`** — "Interrupt Mode 1." On interrupt, jump to address $0038 (the ROM's interrupt handler, which updates system variables and returns).

**`ei`** — "Enable Interrupts." Allows the CPU to respond to interrupt requests. Without this, `halt` would wait forever.

## Build It. Run It.

```bash
pasmo --tapbas inkwar.asm inkwar.tap
```

Load the tape. You should see:

- The game board with a flashing cursor in the top-left
- Press Q — cursor moves up (but it's already at the top, so nothing happens)
- Press A — cursor moves down, the old cell stops flashing
- Press P — cursor moves right
- Press O — cursor moves left

Navigate around the board. The cursor leaves clean, non-flashing cells behind.

## Recap / Sanity Check

- Cursor should move smoothly, about 6 times per second when holding a key
- Old position should stop flashing immediately when you move
- Can't move past the edges (0-7 in both directions)
- If nothing moves, check that interrupts are enabled (`ei`)
- If movement is too fast/slow, adjust `move_delay`

## What You've Built

The game now has:

- **Input handling** — Reading the keyboard matrix directly
- **A game loop** — Frame-based timing with debouncing
- **State management** — Cursor position tracked and updated
- **Visual feedback** — Old cursor cleared, new cursor highlighted

The structure is now: setup → game loop (wait → read input → update state → repeat).

## What You've Learnt

- **Port I/O** — `in a, (c)` reads hardware directly
- **Keyboard matrix** — Half-rows selected via high address byte
- **Bit testing** — `bit n, a` tests without modifying
- **Frame timing** — `halt` synchronises to the 50Hz interrupt
- **Debouncing** — Counting frames prevents too-fast input

## The Complete Code

Here's `inkwar.asm` as it stands after Unit 3:

<CodeFromFile src="sinclair-zx-spectrum/game-01-ink-war/unit-03/inkwar.asm" lang="asm" />

## Next Unit

You can move. But you can't do anything when you get there.

In Unit 4, we add **Claiming Cells** — press SPACE to paint a cell your colour and mark it as your territory.
