---
title: "Claiming Cells"
description: "Paint the board your colour. Learn state arrays and how to permanently change cells."
pubDate: 2026-01-03
game: 1
gameName: "Ink War"
unit: 4
totalUnits: 16
system: "Sinclair ZX Spectrum"
tags: ["assembly", "z80", "game-logic", "arrays"]
nextLesson: "/sinclair-zx-spectrum/assembly/game-01-ink-war/unit-05"
layout: "../../../../layouts/UnitLayout.astro"
---

import CodeFromFile from "@components/CodeFromFile.astro";

*Need to catch up? Check out [Unit 3: Movement](/sinclair-zx-spectrum/game-01-ink-war/unit-03).*

## What You're Building

You can move around, but the board stays white. Time to start claiming territory.

By the end of this unit, you'll have:

- A state array tracking who owns each cell
- SPACE bar input to claim the current cell
- Cells that permanently change colour when claimed
- The beginning of actual gameplay

Press SPACE. Watch the cell turn red. That's yours now.

![A cell claimed by the red player](/images/sinclair-zx-spectrum/game-01-ink-war/unit-04/screenshot.png)

## The Board State

Until now, the board was just pixels. The program didn't "know" what colour each cell was — it just painted them white at startup.

For a game, we need to track ownership:
- **0** = Neutral (white)
- **1** = Player 1 (red)
- **2** = Player 2 (cyan)

We need 64 bytes — one for each cell on the 8×8 board:

<CodeFromFile src="sinclair-zx-spectrum/game-01-ink-war/unit-04/snippets/01-the-board-state.asm" lang="asm" />

**`defs 64`** — "Define Space." Reserves 64 bytes of memory, initialised to zero. Unlike `defb` which sets specific values, `defs` just claims empty space. All cells start as neutral (0).

## Accessing the Array

To read or write `board_state[y][x]`, we calculate the index: `index = (y × 8) + x`

<CodeFromFile src="sinclair-zx-spectrum/game-01-ink-war/unit-04/snippets/02-accessing-the-array.asm" lang="asm" />

This is simpler than `get_cell_addr` — we only need `y × 8` (three rotations) instead of `y × 64`.

## Reading SPACE

SPACE is on the bottom half-row ($7F), bit 0:

<CodeFromFile src="sinclair-zx-spectrum/game-01-ink-war/unit-04/snippets/03-reading-space.asm" lang="asm" />

But there's a problem: if we just check SPACE in the main loop, holding the key would claim cells every frame. We need to detect the **transition** from not-pressed to pressed.

## Debouncing SPACE

We track whether SPACE was already down:

<CodeFromFile src="sinclair-zx-spectrum/game-01-ink-war/unit-04/snippets/04-debouncing-space.asm" lang="asm" />

**`xor a`** — "Exclusive OR A with itself." Always produces zero (and sets the Z flag). A common idiom for "set A to 0 and set Z".

Now SPACE only registers once per press, no matter how long you hold it.

## The Claim Logic

When the player presses SPACE:

1. Check if the cell is neutral (can't claim opponent's cells yet)
2. Update `board_state` to the current player
3. Change the cell's colour on screen

<CodeFromFile src="sinclair-zx-spectrum/game-01-ink-war/unit-04/snippets/05-the-claim-logic.asm" lang="asm" />

## Setting Cell Colours

We need to change the attribute bytes to the player's colour:

<CodeFromFile src="sinclair-zx-spectrum/game-01-ink-war/unit-04/snippets/06-setting-cell-colours.asm" lang="asm" />

We don't preserve the FLASH bit here — when you claim a cell, it becomes solid, not flashing. The cursor will move on and flash somewhere else.

## Integrating with the Game Loop

Add the SPACE check after the movement keys:

<CodeFromFile src="sinclair-zx-spectrum/game-01-ink-war/unit-04/snippets/07-integrating-with-the-game-loop.asm" lang="asm" />

Note: we don't `ret` after claiming. The player might want to move immediately after claiming, so we let the movement checks happen too (they'll fail the debounce check since we just processed input).

Actually, let's keep it simple — if SPACE is pressed, we claim and return:

<CodeFromFile src="sinclair-zx-spectrum/game-01-ink-war/unit-04/snippets/08-integrating-with-the-game-loop.asm" lang="asm" />

## Testing So Far

Build and run. Navigate around and press SPACE:

- White cells turn red when you press SPACE
- The same cell doesn't change if you press SPACE again
- The cursor moves to the red cell and keeps flashing over the red background

Wait — that last one might look odd. A flashing cursor over a red cell swaps between red and... the inverted red (cyan-ish). That's actually fine for now. The FLASH effect still works.

## Build It. Run It.

```bash
pasmo --tapbas inkwar.asm inkwar.tap
```

You should see:
- Move around with Q/A/O/P
- Press SPACE — the cell turns red
- Press SPACE again on the same cell — nothing happens (already claimed)
- Press SPACE on another white cell — it turns red too

You're painting the board. One player at a time, for now.

## Recap / Sanity Check

- Only white (neutral) cells can be claimed
- Claimed cells stay red permanently
- SPACE only registers once per press
- The cursor still flashes, even over red cells
- If cells don't change colour, check `set_cell_colour` is called after `claim_cell` updates the state

## What You've Built

The game now has:

- **State array** — 64 bytes tracking ownership
- **Input debouncing** — Edge detection for single actions
- **Claim logic** — Check validity, update state, update display
- **Visual feedback** — Cells change colour permanently

This is the core gameplay loop taking shape: move → claim → repeat.

## What You've Learnt

- **`defs`** reserves uninitialised memory
- **State vs display** — Track ownership separately from what's on screen
- **Edge detection** — Distinguish "just pressed" from "still held"
- **Array indexing** — `y × width + x` maps 2D to 1D

## The Complete Code

Here's `inkwar.asm` as it stands after Unit 4:

<CodeFromFile src="sinclair-zx-spectrum/game-01-ink-war/unit-04/inkwar.asm" lang="asm" />

## Next Unit

You can paint the board red, but it's a one-player game. Boring.

In Unit 5, we add **Turn Logic** — after you claim a cell, it becomes the other player's turn. Red and cyan take turns conquering the board.
