---
title: "Better AI"
description: "Improve the AI with blocking moves, isolation awareness, and randomness to break ties."
pubDate: 2026-01-04
game: 1
gameName: "Ink War"
unit: 8
totalUnits: 16
system: "Sinclair ZX Spectrum"
tags: ["assembly", "z80", "ai", "strategy"]
nextLesson: "/sinclair-zx-spectrum/assembly/game-01-ink-war/unit-09"
layout: "../../../../layouts/UnitLayout.astro"
---

import CodeFromFile from "@components/CodeFromFile.astro";

*Need to catch up? Check out [Unit 7: Simple AI](/sinclair-zx-spectrum/game-01-ink-war/unit-07).*

## What You're Building

The AI from Unit 7 works, but it's predictable. It always picks the first cell when scores tie, creating a top-left bias you can exploit. It doesn't block threats or avoid isolation.

By the end of this unit, you'll have:

- **Blocking behaviour** — The AI recognises when you're building a strong frontier and blocks it
- **Randomness** — Ties are broken unpredictably using a frame counter
- **Smarter scoring** — The AI avoids isolated cells and values connected territory

![AI blocking player expansion](/images/sinclair-zx-spectrum/game-01-ink-war/unit-08/screenshot.png)

## The Improved Heuristics

We keep the basic scoring from Unit 7 but add two enhancements:

1. **Blocking bonus** — If a cell is adjacent to 2+ enemy cells, claim it before the opponent builds a wall
2. **Random tie-breaker** — Add 0 or 1 to the score based on a frame counter, so equal scores don't always pick the same cell

## Adding a Frame Counter

We need a simple source of randomness. A frame counter that increments every main loop iteration works well:

<CodeFromFile src="sinclair-zx-spectrum/game-01-ink-war/unit-08/snippets/01-adding-a-frame-counter.asm" lang="asm" />

In the main loop:

<CodeFromFile src="sinclair-zx-spectrum/game-01-ink-war/unit-08/snippets/02-adding-a-frame-counter.asm" lang="asm" />

The counter constantly changes, so whenever the AI evaluates cells, it gets a different "random" tie-breaker.

## Counting Enemy Neighbours

To detect threats, we count how many neighbours belong to the enemy:

<CodeFromFile src="sinclair-zx-spectrum/game-01-ink-war/unit-08/snippets/03-counting-enemy-neighbours.asm" lang="asm" />

This routine follows the same pattern as our adjacency checks but counts matches instead of returning on the first one.

## The Improved Scoring

Update `score_cell` to include blocking and randomness:

<CodeFromFile src="sinclair-zx-spectrum/game-01-ink-war/unit-08/snippets/04-the-improved-scoring.asm" lang="asm" />

**`and %00000001`** — Masks off all bits except bit 0, giving us either 0 or 1. This tiny random factor breaks ties between equally-scored cells without significantly affecting the heuristics.

**`jr c, .no_block`** — "Jump Relative if Carry." After `cp 2`, the carry flag is set if A < 2. So if there are 0 or 1 enemy neighbours, we skip the blocking bonus.

## Why This Works

The blocking bonus (+4) is large enough to matter but not so large that it overrides everything else. Consider:

- A cell next to 2 friendly cells: +6 (3+3)
- A cell next to 2 enemy cells: +4 (from blocking) - 4 (penalty) = 0, but +4 blocking = +4
- A cell next to 1 friendly + 2 enemy: +3 - 4 + 4 = +3

The AI still prefers connected friendly territory, but now it recognises when blocking is valuable.

The randomness (+0 or +1) is too small to override good decisions but enough to vary choices when cells score equally.

## The Complete Flow

The AI now:

1. Scans all empty cells adjacent to its territory
2. Scores each based on: friendly neighbours (+3), neutral (+1), enemy (-2)
3. Adds blocking bonus (+4) if ≥2 enemy neighbours
4. Adds random tie-breaker (+0 or +1)
5. Picks the highest-scoring cell

## Build It. Run It.

```bash
pasmo --tapbas inkwar.asm inkwar.tap
```

Load the tape in your emulator. Play several games and observe:

- The AI no longer always picks the same cells
- When you build a line of cells, the AI tries to cut you off
- The AI still prefers connected territory but is less exploitable

## Recap / Sanity Check

- Frame counter increments every main loop iteration
- AI varies its choices when scores tie
- AI blocks when you have 2+ cells adjacent to a position
- AI still prioritises growing its own territory
- The game feels more competitive

## What You've Built

Look at what changed from Unit 7:

- **`frame_counter`** — Simple randomness source
- **`count_enemy_neighbours`** — Detects threat patterns
- **Modified `score_cell`** — Includes blocking bonus and randomness
- **Modified main loop** — Increments frame counter

The AI is now a more worthy opponent.

## What You've Learnt

- **Bit masking** — `and %00000001` extracts a single bit for randomness
- **Threat detection** — Counting enemy neighbours identifies blocking opportunities
- **Heuristic balance** — Bonus values need tuning to create good behaviour
- **Simple randomness** — A frame counter provides cheap unpredictability

## The Complete Code

Here's `inkwar.asm` as it stands after Unit 8:

<CodeFromFile src="sinclair-zx-spectrum/game-01-ink-war/unit-08/inkwar.asm" lang="asm" />

## Next Unit

The AI is smarter, but the game never ends. You just keep playing until the board fills up — or get bored.

In Unit 9, we'll add **Win Detection** — counting territories and declaring a winner when the game is over.
