---
title: "The Cursor"
description: "Create an active cursor. Learn how to modify attributes dynamically to highlight the selected cell."
pubDate: 2026-01-03
game: 1
gameName: "Ink War"
unit: 2
totalUnits: 16
system: "Sinclair ZX Spectrum"
tags: ["assembly", "z80", "attributes", "flash"]
nextLesson: "/sinclair-zx-spectrum/assembly/game-01-ink-war/unit-03"
layout: "../../../../layouts/UnitLayout.astro"
---

import CodeFromFile from "@components/CodeFromFile.astro";

*Need to catch up? Check out [Unit 1: The Board](/sinclair-zx-spectrum/game-01-ink-war/unit-01).*

## What You're Building

The board is set, but you can't tell where you are. We need a cursor.

By the end of this unit, you'll have:

- A blinking cursor highlighting the current cell
- A way to track player position in memory
- The Spectrum doing the animation work for you (zero CPU cost)

No movement yet. Just the cursor, blinking at you, waiting for input.

![The cursor flashing on the top-left cell](/images/sinclair-zx-spectrum/game-01-ink-war/unit-02/screenshot.png)

## The FLASH Bit

In modern games, a cursor might be a sprite or an animated outline. On the Spectrum, we use the **FLASH** attribute — and the hardware does all the work.

Remember the attribute byte from Unit 1?

```
  7   6   5   4   3   2   1   0
┌───┬───┬───────────┬───────────┐
│ F │ B │  PAPER    │   INK     │
└───┴───┴───────────┴───────────┘
```

Bit 7 is FLASH. Set it to 1, and the Spectrum automatically swaps INK and PAPER colours every 16 frames — roughly twice a second. The ULA handles this; your code doesn't need to do anything after setting the bit.

This is perfect for a cursor. Set the bit, forget about it. The blinking happens for free.

## The Challenge

Our game board uses 2×2 character cells. One game cell = four attribute bytes:

```
Game cell (x, y):
┌─────────┬─────────┐
│ Top-L   │ Top-R   │   ← Row y*2
├─────────┼─────────┤
│ Bot-L   │ Bot-R   │   ← Row y*2+1
└─────────┴─────────┘
  Col x*2   Col x*2+1
```

To highlight a cell, we need to set the FLASH bit on all four attribute bytes. And we need to calculate where those bytes are in memory.

## The Plan

We need three things:

1. **Variables** to track cursor position (0-7 for both X and Y)
2. **A routine** to calculate the attribute address from game coordinates
3. **A routine** to set the FLASH bit on all four bytes of a cell

Let's build each piece.

## Tracking Position

Add these variables to your data section:

<CodeFromFile src="sinclair-zx-spectrum/game-01-ink-war/unit-02/snippets/01-tracking-position.asm" lang="asm" />

The cursor starts at (0, 0) — the top-left cell of the game board.

## Calculating the Address

The game board starts at screen row 4, column 8. In attribute memory, that's address 22664.

From there, we need to calculate the offset:
- Each game row = 2 screen rows = 64 bytes (32 bytes × 2)
- Each game column = 2 screen columns = 2 bytes

So: `address = 22664 + (cursor_y × 64) + (cursor_x × 2)`

<CodeFromFile src="sinclair-zx-spectrum/game-01-ink-war/unit-02/snippets/02-calculating-the-address.asm" lang="asm" />

**`rlca`** — "Rotate Left Circular Accumulator." Shifts all bits in A one position left, with bit 7 wrapping to bit 0. Each rotation doubles the value. Six rotations = multiply by 64.

**Building DE from A** — We need to add an 8-bit offset to a 16-bit address. `ld e, a` puts our offset in the low byte; `ld d, 0` clears the high byte. Then `add hl, de` does the 16-bit addition.

## Setting the FLASH Bit

Once we have the address, we modify all four attribute bytes:

<CodeFromFile src="sinclair-zx-spectrum/game-01-ink-war/unit-02/snippets/03-setting-the-flash-bit.asm" lang="asm" />

**`set 7, a`** — "Set bit 7 of A to 1." The Z80 has dedicated bit manipulation instructions:
- `set n, r` — Set bit n to 1
- `res n, r` — Reset bit n to 0
- `bit n, r` — Test bit n (sets zero flag if bit is 0)

These work on any bit (0-7) of any main register. Here we're setting the FLASH bit without disturbing the colour bits.

**Why 31?** — The attribute table is 32 bytes per row. After `inc hl` we're at the top-right byte. To reach the bottom-left, we need to go down one row (32 bytes) and back one column (-1 byte). That's 31.

## Putting It Together

Now we modify the main program flow. After drawing the board, we highlight the cursor:

<CodeFromFile src="sinclair-zx-spectrum/game-01-ink-war/unit-02/snippets/04-putting-it-together.asm" lang="asm" />

The cursor position lives in memory. We load it into A, then transfer to the register the subroutine expects (B for row, C for column). This pattern — load from memory, shuffle into the right register — is common in Z80 code.

## Build It. Run It.

```bash
pasmo --tapbas inkwar.asm inkwar.tap
```

Load the tape in your emulator. You should see:

- The same 8×8 game board from Unit 1
- The top-left cell flashing between its normal colour and inverted

The cursor is alive. It's asking to be moved.

## Recap / Sanity Check

- The top-left cell should flash roughly twice per second
- All four character cells of that game cell should flash together
- The other 63 cells should be static
- If nothing flashes, check that `set 7, a` is being executed and written back
- If only part of the cell flashes, check your address arithmetic

## What You've Built

Look at what changed from Unit 1:

- **Cursor variables** — Two bytes tracking where the player is
- **Address calculation** — Translating game coordinates to memory addresses
- **Attribute modification** — Changing one bit without touching the others
- **Hardware-assisted animation** — The ULA does the flashing, not your code

The structure is now: set up display → draw board → highlight cursor → wait.

## What You've Learnt

- **FLASH bit** (bit 7) gives you free animation from the hardware
- **Bit instructions** (`set`, `res`, `bit`) modify individual bits
- **Address arithmetic** converts logical coordinates to memory locations
- **The 32-byte row** — attribute table is 32 bytes wide, always

## The Complete Code

Here's `inkwar.asm` as it stands after Unit 2:

<CodeFromFile src="sinclair-zx-spectrum/game-01-ink-war/unit-02/inkwar.asm" lang="asm" />

## Next Unit

The cursor is flashing. But it's stuck in the corner.

In Unit 3, we'll read the keyboard — Q, A, O, P — and make the cursor move around the board. The game starts to feel interactive.
