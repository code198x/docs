---
title: "Difficulty Progression"
description: "Keep the challenge fresh. Dynamic speed adjustments reward skilled players with faster, more intense gameplay."
pubDate: 2025-11-26
game: 1
gameName: "SID Symphony"
unit: 13
totalUnits: 16
system: "Commodore 64"
tags: ["assembly", "6510", "difficulty", "speed", "progression"]
prevLesson: "/commodore-64/assembly/game-01-sid-symphony/unit-12"
nextLesson: "/commodore-64/assembly/game-01-sid-symphony/unit-14"
layout: "../../../../layouts/UnitLayout.astro"
---

import CodeFromFile from "@components/CodeFromFile.astro";

## The Boredom Problem

A fixed difficulty creates two failure modes. Beginners struggle and give up. Experts get bored and move on. Neither plays for long.

The solution: dynamic difficulty. As players demonstrate skill, increase the challenge. As they struggle, ease off. The game stays in the "flow" zone — difficult enough to engage, not so hard it frustrates.

## Speed as Difficulty

In a rhythm game, note speed is the obvious difficulty lever. Faster notes demand quicker reactions. We already have a skill indicator: the multiplier. High multiplier means the player is hitting notes consistently. Reward that consistency with a greater challenge.

<CodeFromFile src="commodore-64/game-01-sid-symphony/unit-13/snippets/01-speed-as-difficulty.asm" lang="asm" />

At 1x, notes move every 4 frames. At 4x, they move every 2 frames — twice as fast. The jump from 2x to 3x is a plateau, giving players a brief respite before the final push.

## Table Lookup

Rather than calculate speed from multiplier each time, we use a lookup table. This is a common 6502 pattern — trading a few bytes of memory for faster execution:

<CodeFromFile src="commodore-64/game-01-sid-symphony/unit-13/snippets/02-table-lookup.asm" lang="asm" />

The multiplier ranges from 1-4, but array indices start at 0. We subtract 1 before indexing:

<CodeFromFile src="commodore-64/game-01-sid-symphony/unit-13/snippets/03-table-lookup.asm" lang="asm" />

Three instructions to look up and store the new speed. Fast and simple.

## Triggering Speed Changes

Speed updates whenever the multiplier changes. That happens in two places: when it increases (combo threshold reached) and when it resets (miss).

<CodeFromFile src="commodore-64/game-01-sid-symphony/unit-13/snippets/04-triggering-speed-changes.asm" lang="asm" />

<CodeFromFile src="commodore-64/game-01-sid-symphony/unit-13/snippets/05-triggering-speed-changes.asm" lang="asm" />

## Using Current Speed

The game loop uses `current_speed` instead of moving notes every frame. We add a `move_timer` that counts down:

<CodeFromFile src="commodore-64/game-01-sid-symphony/unit-13/snippets/06-using-current-speed.asm" lang="asm" />

When `move_timer` hits zero, we reload it from `current_speed`. At higher multipliers, this value is smaller, so the timer expires more often, moving notes more frequently.

## Initialisation

Reset the speed variables when starting a new game:

<CodeFromFile src="commodore-64/game-01-sid-symphony/unit-13/snippets/07-initialisation.asm" lang="asm" />

## The Feel

Watch how this changes the game:

1. Player starts at 1x — comfortable pace
2. Builds combo, hits 2x — notes speed up
3. Adapts to new speed, hits 3x — same speed (breathing room)
4. Pushes through to 4x — notes fly
5. One miss — back to 1x, sudden slowdown

The speed changes create drama. Reaching 4x feels like an achievement. Losing it feels like a fall. The game becomes a story of rises and crashes, not just a steady rhythm.

## Why Not Continuous Scaling?

We could calculate speed as `5 - multiplier`. But discrete steps feel better. Each multiplier level has a distinct character. Players can think "I'm at 3x speed" rather than feeling lost on a sliding scale.

The plateau at 3x is deliberate. After two speed increases, players need time to consolidate. The jump to 4x then feels special — the final challenge.

## Alternative Approaches

Other ways to increase difficulty:

- **More notes**: Spawn notes more frequently at higher multipliers
- **Narrower windows**: Shrink the Perfect zone as skill increases
- **Pattern complexity**: Introduce chord hits earlier at higher levels
- **Visual noise**: Add distractions as difficulty climbs

Speed is the simplest lever. The others add complexity without proportional payoff.

## The Complete Code

<CodeFromFile src="commodore-64/game-01-sid-symphony/unit-13/symphony.asm" lang="asm" />

## What's Next

The game now adapts to player skill. In Unit 14, we add **high score persistence** — saving the best score so players have a target to beat across sessions.
