---
title: "High Score"
description: "Give players a target. Tracking and displaying the best score creates replayability and personal challenge."
pubDate: 2025-11-26
game: 1
gameName: "SID Symphony"
unit: 14
totalUnits: 16
system: "Commodore 64"
tags: ["assembly", "6510", "high-score", "persistence", "comparison"]
prevLesson: "/commodore-64/assembly/game-01-sid-symphony/unit-13"
nextLesson: "/commodore-64/assembly/game-01-sid-symphony/unit-15"
layout: "../../../../layouts/UnitLayout.astro"
---

import CodeFromFile from "@components/CodeFromFile.astro";

## The Target

A game without a high score is a game without memory. Each session exists in isolation — players have no sense of progress, no target to beat, no reason to replay.

The high score changes everything. Now there's a goal beyond "finish the song." Players compete against their past selves, pushing for that extra perfect hit, taking risks to maintain their multiplier.

## Storage

High score needs two bytes — same as the regular score. But unlike the regular score, it persists across games within a session:

<CodeFromFile src="commodore-64/game-01-sid-symphony/unit-14/snippets/01-storage.asm" lang="asm" />

Note what we're NOT doing: saving to disk. That's complexity we don't need. The high score persists as long as the program runs. Turn off the machine, it resets. This is how most arcade games worked — and it's enough to create that competitive tension.

## Comparison

After each game ends, we compare the current score against the high score. This requires 16-bit comparison — check the high byte first, only compare low bytes if the high bytes are equal:

<CodeFromFile src="commodore-64/game-01-sid-symphony/unit-14/snippets/02-comparison.asm" lang="asm" />

The logic flow:
1. Compare high bytes
2. If current high byte is less, we're done (not a record)
3. If current high byte is greater, it's a new record
4. If equal, compare low bytes
5. Only update if current is strictly greater

## Triggering the Check

The high score check happens at game end — both victory and game over:

<CodeFromFile src="commodore-64/game-01-sid-symphony/unit-14/snippets/03-triggering-the-check.asm" lang="asm" />

<CodeFromFile src="commodore-64/game-01-sid-symphony/unit-14/snippets/04-triggering-the-check.asm" lang="asm" />

## Display

The end screens now show both the current score and the high score. We draw the high score in yellow to distinguish it:

<CodeFromFile src="commodore-64/game-01-sid-symphony/unit-14/snippets/05-display.asm" lang="asm" />

We draw the high score using the same digit conversion logic, but reading from `high_score_lo/hi` instead.

## The Psychology

Watch how players behave with a high score:

1. First game: They're learning, score doesn't matter
2. Second game: Now they have a target — their first score
3. Third game: They beat it! New target set
4. Fourth game: They fall short. Frustration drives one more try...

This loop is addictive. The high score turns a five-minute game into a thirty-minute session. Players aren't just playing — they're competing.

## Why Not Save to Disk?

Saving to disk would make the high score truly persistent. But consider:

- **Complexity**: File I/O on the C64 involves serial communication, error handling, and file management
- **Speed**: Disk operations are slow and would interrupt the flow
- **Authenticity**: Arcade games didn't save high scores (mostly)
- **Scope**: This is Unit 14 of 16 — we have other features to add

The simple approach works. Save disk I/O for a later lesson.

## The Complete Code

<CodeFromFile src="commodore-64/game-01-sid-symphony/unit-14/symphony.asm" lang="asm" />

## What's Next

The game now tracks achievements across plays. In Unit 15, we add **pause functionality** — letting players take a break mid-song without losing progress.
