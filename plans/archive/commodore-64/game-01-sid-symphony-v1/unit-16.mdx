---
title: "Polish"
description: "Ship it. Final touches, version number, and reflections on completing a game from start to finish."
pubDate: 2025-11-26
game: 1
gameName: "SID Symphony"
unit: 16
totalUnits: 16
system: "Commodore 64"
tags: ["assembly", "6510", "polish", "documentation", "release"]
prevLesson: "/commodore-64/assembly/game-01-sid-symphony/unit-15"
nextLesson: "/commodore-64"
layout: "../../../../layouts/UnitLayout.astro"
---

import CodeFromFile from "@components/CodeFromFile.astro";


*Need to catch up? Check out [Unit 15: Pause](/commodore-64/game-01-sid-symphony/unit-15).*

## The Final Unit

We've built a complete rhythm game. Three tracks, SID audio, timing grades, combos, multipliers, difficulty progression, high scores, and pause. The game works.

This unit is different. No new gameplay features. Instead, we polish: clean up the code, add a version number, and reflect on what we've built.

## Version String

Professional software has version numbers. They help players know which version they're running, and help you track bug reports:

<CodeFromFile src="commodore-64/game-01-sid-symphony/unit-16/snippets/01-version-string.asm" lang="asm" />

We display it on the title screen, below the game title in grey — visible but unobtrusive:

<CodeFromFile src="commodore-64/game-01-sid-symphony/unit-16/snippets/02-version-string.asm" lang="asm" />

## Header Comments

The file header now documents the complete game:

<CodeFromFile src="commodore-64/game-01-sid-symphony/unit-16/snippets/03-header-comments.asm" lang="asm" />

Future you (or anyone reading the code) immediately understands what this program does.

## What We Built

Let's review the journey:

| Unit | Feature | Key Technique |
|------|---------|---------------|
| 1 | Screen setup | Memory-mapped I/O |
| 2 | Game structure | State machine |
| 3 | Note spawning | Object pools |
| 4 | Note movement | Frame-based animation |
| 5 | Hit detection | Position comparison |
| 6 | SID audio | Register programming |
| 7 | Crowd meter | Visual feedback loop |
| 8 | Song data | Data-driven design |
| 9 | Sound effects | Audio layering |
| 10 | Timing grades | Precision windows |
| 11 | Combo system | Reward mechanics |
| 12 | Visual juice | Screen effects |
| 13 | Difficulty | Dynamic balancing |
| 14 | High score | 16-bit comparison |
| 15 | Pause | State preservation |
| 16 | Polish | Documentation |

Each unit introduced one concept. Together, they form a complete game.

## Code Size

The final program is approximately 3.7KB. That includes:

- All game logic
- Screen drawing routines
- SID audio code
- Complete song data
- All text strings

Modern games measure in gigabytes. We built a playable experience in under 4KB.

## What's Missing

A shipped game is never truly finished. Features we could add:

- **Multiple songs**: Song selection screen, different melodies
- **Difficulty levels**: Easy/Normal/Hard with different speeds
- **Save to disk**: Persistent high scores across sessions
- **Two-player mode**: Competitive or cooperative play
- **Custom graphics**: Character set with styled fonts

Each would be a lesson in itself. The foundation is here.

## The 6502 Mindset

Building this game taught patterns that apply to all 6502 development:

**Think in bytes.** Every variable, every constant, every piece of data is one or two bytes. This constraint focuses design.

**Tables over calculations.** The speed lookup table, the note frequency table — pre-computed data beats runtime maths.

**State machines work.** Title, playing, paused, game over, victory — five states, clean transitions, predictable behaviour.

**Memory is I/O.** Write to $D020, the border changes colour. Write to $D400, the SID makes sound. Direct, immediate, powerful.

## Build It. Run It.

Assemble and run one final time:

```bash
acme -f cbm -o sidsymphony.prg sidsymphony.asm
x64sc sidsymphony.prg
```

## Congratulations

You've completed SID Symphony. From an empty screen to a playable rhythm game, you've written every line of code, understood every byte.

This is real game development. Not a framework, not an engine — raw assembly, talking directly to hardware. The same techniques that powered commercial C64 games in the 1980s.

Take what you've learned and build something new.

## The Complete Code

<CodeFromFile src="commodore-64/game-01-sid-symphony/unit-16/symphony.asm" lang="asm" title="symphony.asm" />
