---
title: "Song Data"
description: "Replace fixed spawning with authored song data. Notes appear when the song says they should, not on a timer."
pubDate: 2025-11-26
game: 1
gameName: "SID Symphony"
unit: 7
totalUnits: 16
system: "Commodore 64"
tags: ["assembly", "6510", "data-driven", "pointers", "indirect-addressing"]
prevLesson: "/commodore-64/assembly/game-01-sid-symphony/unit-06"
nextLesson: "/commodore-64/assembly/game-01-sid-symphony/unit-08"
layout: "../../../../layouts/UnitLayout.astro"
---

import CodeFromFile from "@components/CodeFromFile.astro";

import InlineNote from "../../../../components/units/InlineNote.astro";

*Need to catch up? Check out [Unit 6: Three Voices](/commodore-64/game-01-sid-symphony/unit-06).*

## What You're Building

Notes spawn on a fixed timer. Track 0, track 1, track 2, repeat. That's predictable — not musical. Real rhythm games have authored patterns.

By the end of this unit, you'll have:

- Song data that specifies exactly when each note appears
- Delta timing — each note says "wait N frames after the previous note"
- Track assignment from data, not rotation
- Song completion detection
- The same engine playing any song you write

## The Power of Data-Driven Design

Here's the key insight: **the game engine doesn't change — only the data does**.

The same code that plays a simple test pattern can play a complex musical piece. The code doesn't know or care what song it's playing. It just reads data and spawns notes.

This is data-driven design. It's how real games work.

## Song Data Format

Each note is two bytes: delta time and track.

<CodeFromFile src="commodore-64/game-01-sid-symphony/unit-07/snippets/01-song-data-format.asm" lang="asm" />

Why delta timing instead of absolute timestamps? Absolute timestamps overflow a byte quickly — 255 frames is only about 5 seconds at 50fps. Delta timing allows songs of any length.

## The Song Pointer

We need to track where we are in the song:

<CodeFromFile src="commodore-64/game-01-sid-symphony/unit-07/snippets/02-the-song-pointer.asm" lang="asm" />

The pointer must be in zero page for indirect addressing to work. We use `$fd-$fe`, separate from our screen pointer at `$fb-$fc`.

## Initialising the Song

<CodeFromFile src="commodore-64/game-01-sid-symphony/unit-07/snippets/03-initialising-the-song.asm" lang="asm" />

The `<` and `>` operators extract the low and high bytes of an address. `#<song_data` gives the low byte of wherever `song_data` lives in memory.

## Reading Song Data

Every frame, we check if it's time for the next note:

<CodeFromFile src="commodore-64/game-01-sid-symphony/unit-07/snippets/04-reading-song-data.asm" lang="asm" />

This replaces the fixed spawn timer entirely. Notes appear exactly when the song data says.

<InlineNote>
The instruction `lda (song_ptr),y` is indirect indexed addressing. It reads the 16-bit address from `song_ptr` ($fd-$fe), adds Y, and loads from that address. This is how we read sequential data through a pointer.
</InlineNote>

## Spawn on Specific Track

Instead of rotating through tracks, we spawn on the track specified by the song:

<CodeFromFile src="commodore-64/game-01-sid-symphony/unit-07/snippets/05-spawn-on-specific-track.asm" lang="asm" />

The track comes from the song data, not a rotating counter.

## A Real Pattern

The song in this unit has structure:

<CodeFromFile src="commodore-64/game-01-sid-symphony/unit-07/snippets/06-a-real-pattern.asm" lang="asm" />

The "chord" moments — notes spawning 3 frames apart — arrive almost simultaneously, requiring you to hit all three keys together.

## Build It. Run It.

Assemble and run:

```bash
acme -o symphony.prg symphony.asm
x64sc symphony.prg
```

Watch the pattern unfold. It's not random — it's authored. The intro eases you in, the middle builds intensity, and the chord hits demand precision.

## What You've Learnt

- **Delta timing**: Relative timestamps that don't overflow
- **Zero page pointers**: Required for indirect addressing
- **Indirect indexed addressing**: `lda (ptr),y` for reading through pointers
- **Data-driven design**: Same code, different data, different experience

## Next Unit

The engine works. Three tracks, song data, scoring, crowd reactions. But we need a proper game flow with title screen, game states, and restart capability.

In [Unit 8: The Performance](/commodore-64/game-01-sid-symphony/unit-08), we add state management — title, playing, game over, and victory states with transitions between them.

## The Complete Code

Here's the complete `symphony.asm` including all features from Units 1-7:

<CodeFromFile src="commodore-64/game-01-sid-symphony/unit-07/symphony.asm" lang="asm" />

