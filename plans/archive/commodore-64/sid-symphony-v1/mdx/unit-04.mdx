---
title: "Playing a Scale"
description: "From single notes to melody. Build a frequency table and play your first musical sequence."
pubDate: 2026-01-08
game: 1
gameName: "SID Symphony"
unit: 4
totalUnits: 64
system: "Commodore 64"
tags: ["assembly", "6510", "sid", "frequency-table", "indexed-addressing", "melody"]
prevLesson: "/commodore-64/assembly/game-01-sid-symphony/unit-03"
nextLesson: "/commodore-64/assembly/game-01-sid-symphony/unit-05"
layout: "../../../../layouts/UnitLayout.astro"
---

import CodeFromFile from "@components/CodeFromFile.astro";
import InlineNote from "../../../../components/units/InlineNote.astro";

*Need to catch up? Check out [Unit 3: ADSR Envelopes](/commodore-64/assembly/game-01-sid-symphony/unit-03).*

## What You're Building

We've played notes. We've shaped them with envelopes. But we've been stuck with hardcoded frequencies — one note at a time, manually specified.

Music needs *sequences*. Melodies. A way to say "play these notes in this order."

By the end of this unit, you'll have:

- A frequency lookup table covering one octave
- Code that plays notes by index (0-7) rather than raw frequency
- An ascending and descending C major scale
- The foundation for playing any melody

Listen to the result. That's not sound effects — that's *music*.

## The Frequency Table

Hardcoding `lda #$68` / `sta SID_V1_FREQ_LO` for every note doesn't scale. We need a table we can index into.

The 6502 can only load one byte at a time, so we split the 16-bit frequencies into two parallel tables:

<CodeFromFile src="commodore-64/game-01-sid-symphony/unit-04/snippets/01-frequency-table.asm" />

Note index 0 is C4, index 1 is D4, and so on up to index 7 (C5).

<InlineNote>
These values are calculated for PAL C64 (985248 Hz clock). NTSC values would be slightly different. Most games used PAL values regardless — the pitch difference is barely noticeable.
</InlineNote>

## Indexed Addressing

The X register becomes our note selector. The instruction `lda freq_lo,x` means "load from address freq_lo plus X":

<CodeFromFile src="commodore-64/game-01-sid-symphony/unit-04/snippets/02-indexed-addressing.asm" />

This is the key insight: **data drives the music, not code**. The same `play_note` subroutine plays any note — you just change X.

## The Play Note Subroutine

Each note needs: set frequency, gate on, wait, gate off, brief gap:

<CodeFromFile src="commodore-64/game-01-sid-symphony/unit-04/snippets/03-play-note.asm" />

The subroutine preserves X across the call, so the main loop can track which note we're on.

## The Scale Loop

Playing a scale is just a loop that increments (or decrements) the note index:

<CodeFromFile src="commodore-64/game-01-sid-symphony/unit-04/snippets/04-scale-loop.asm" />

Ascending: X goes 0→1→2→3→4→5→6→7 (C up to C)
Descending: X goes 6→5→4→3→2→1→0 (B down to C, skipping the top C to avoid repeating it)

## Frame-Based Timing

`NOTE_DURATION = 25` means each note plays for 25 frames. At 50fps (PAL), that's half a second per note. The scale takes about 7.5 seconds to complete one cycle.

Timing by frame counting is fundamental to C64 programming. The raster beam gives us a reliable 50Hz (or 60Hz on NTSC) clock to synchronise against.

## Build It. Run It.

```bash
acme -f cbm -o symphony.prg symphony.asm
x64sc symphony.prg
```

You'll hear: C-D-E-F-G-A-B-C (up), then B-A-G-F-E-D-C (down), repeating forever.

Experiments to try:
1. Change `NOTE_DURATION` to 10 — hear the scale race by
2. Change the envelope to pluck style (`AD = $03`, `SR = $00`) — hear a harp
3. Add sharps/flats to the table — hear a chromatic scale

## What You've Learnt

- **Lookup tables**: Store data separately from code; access by index
- **Indexed addressing**: `lda table,x` reads from table + X offset
- **Subroutines**: Reusable code called with `jsr`, returns with `rts`
- **Frame-based timing**: Count frames for consistent note durations

## The Complete Code

<CodeFromFile src="commodore-64/game-01-sid-symphony/unit-04/symphony.asm" />

## Phase 1 Complete: Sound Foundation

Units 1-4 have established the SID fundamentals:
- Unit 1: First contact with memory-mapped sound
- Unit 2: Three voices and four waveforms
- Unit 3: ADSR envelope shaping
- Unit 4: Frequency tables and melodic playback

You can now make the C64 play music. But it's all still a black screen.

In Unit 5, we finally draw something — the screen layout that will become our rhythm game's stage.
