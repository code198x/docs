---
title: "Title Screen"
description: "First impressions matter. Create an animated title screen with colour cycling, blinking prompts, and a polished introduction."
pubDate: 2026-01-09
game: 1
gameName: "SID Symphony"
unit: 16
totalUnits: 16
system: "Commodore 64"
tags: ["assembly", "6510", "title-screen", "animation", "polish"]
prevLesson: "/commodore-64/assembly/game-01-sid-symphony/unit-15"
layout: "../../../../layouts/UnitLayout.astro"
---

import CodeFromFile from "@components/CodeFromFile.astro";
import InlineNote from "../../../../components/units/InlineNote.astro";

*Need to catch up? Check out [Unit 15: Song Completion](/commodore-64/assembly/game-01-sid-symphony/unit-15).*

## What You're Building

The game is complete — playable, winnable, loseable. But it starts abruptly. Run the program and notes immediately begin flowing. No introduction, no branding, no chance to prepare.

By the end of this unit, you'll have:

- An animated title screen
- Colour-cycling title text
- Blinking "Press SPACE to play" prompt
- Credits display
- Smooth transition into gameplay

This is the final polish that makes a game feel *finished*.

## Title Screen Structure

The title screen runs before the game initialises:

<CodeFromFile src="commodore-64/game-01-sid-symphony/unit-16/snippets/01-title-structure.asm" />

Important: `setup_charset` must run before the title screen because the title uses custom characters. But `init` runs after — we don't want to set up game state until the player is ready.

The title loop:
1. Wait for raster (50 fps timing)
2. Animate title colours
3. Animate prompt visibility
4. Check for SPACE key
5. Repeat until SPACE pressed
6. Brief pause, then return to continue to `init`

## Colour Cycling

The title pulses through colours to catch the eye:

<CodeFromFile src="commodore-64/game-01-sid-symphony/unit-16/snippets/02-colour-cycling.asm" />

The animation uses a frame counter divided by 4 (two right shifts) for smooth, unhurried transitions. Eight colour steps create a subtle pulse:

```
cyan → cyan → white → white → cyan → cyan → grey → grey → (repeat)
```

The `and #7` ensures the counter wraps at 8, creating an endless loop.

<InlineNote>
Colour cycling was a signature effect of 8-bit era games. With no sprite animation budget, cycling colours through static text created eye-catching motion for nearly zero CPU cost.
</InlineNote>

## Prompt Blinking

The "Press SPACE to play" text blinks to draw attention:

<CodeFromFile src="commodore-64/game-01-sid-symphony/unit-16/snippets/03-prompt-blinking.asm" />

We reuse the animation frame counter but check bit 5 (`and #$20`). This bit toggles every 32 frames — roughly 0.6 seconds on PAL (32 ÷ 50 fps = 0.64s).

To "hide" text, we don't erase it — we set its colour to match the background (black). The characters remain in screen memory; only their visibility changes.

## The Complete Flow

The program now has distinct phases:

```
start:
    ├── setup_charset     ; Prepare custom graphics
    ├── title_screen      ; Show title, wait for SPACE
    └── init              ; Set up game state
        └── main_loop     ; Play the game
            ├── (gameplay happens)
            ├── check_game_over   ; Fail → GAME OVER
            └── check_song_complete ; Win → RESULTS
                └── (both offer restart → jump to start)
```

Notice that restart jumps to `start`, not `init`. This means players see the title screen again after each game — a full reset that feels like launching the program fresh.

## Polish Details

Small touches that elevate the experience:

**Brief pause after SPACE**: The 30-frame delay (0.6 seconds) prevents the abrupt feeling of immediate transition. The player has time to release the spacebar before gameplay begins.

**Credits line**: "CODE LIKE IT'S 198X" gives attribution and personality. Professional games always credited their creators.

**Consistent colours**: The title uses the same cyan as Track 1, establishing visual identity before gameplay begins.

## Build It. Run It.

```bash
acme -f cbm -o symphony.prg symphony.asm
x64sc symphony.prg
```

Watch the title screen. See the title pulse through colours. Watch "PRESS SPACE TO PLAY" blink. Press SPACE and notice the brief pause before gameplay begins.

Play through, win or lose, choose replay — you're back at the title screen. The game now has a proper lifecycle.

## What You've Learnt

- **Program flow**: Title screen before game init
- **Colour cycling**: Frame counter + lookup table for animation
- **Visibility toggle**: Change colour to background to "hide" text
- **Bit masking for timing**: `and #$20` for 32-frame toggle
- **Polish matters**: Small details create professional feel

## The Complete Code

<CodeFromFile src="commodore-64/game-01-sid-symphony/unit-16/symphony.asm" />

## Congratulations!

You've built a complete game from scratch in 6510 assembly:

- **SID sound**: Voices, waveforms, ADSR envelopes
- **Custom graphics**: Character set modification
- **Game loop**: Raster-synchronised 50 fps timing
- **Data structures**: Parallel arrays for note management
- **Input handling**: Keyboard matrix scanning with debouncing
- **Hit detection**: Matching keys to notes in zones
- **Scoring**: BCD arithmetic for easy display
- **Health system**: Performance tracking with game over
- **Victory conditions**: Song completion detection
- **Results screen**: Rating based on score
- **Title screen**: Animated introduction

This is real game development. Every commercial rhythm game — from Dance Dance Revolution to Guitar Hero — uses these same fundamental concepts.

**What's next?** The foundation you've built can expand:
- Add more songs with different patterns
- Implement difficulty levels (faster movement, tighter hit zones)
- Add combo bonuses for consecutive hits
- Create visual effects for perfect timing
- Add a high score table

Or take what you've learnt to build something entirely new. You now understand how the C64 thinks — go make it sing.
