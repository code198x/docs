---
title: "The Frog"
description: "Add a hardware sprite to the scene. Learn how the Amiga handles sprite data, DMA, and positioning."
pubDate: 2026-01-03
game: 1
gameName: "Hop"
unit: 2
totalUnits: 16
system: "Commodore Amiga"
tags: ["assembly", "68000", "sprites", "dma"]
nextLesson: "/commodore-amiga/assembly/game-01-signal/unit-03"
layout: "../../../../layouts/UnitLayout.astro"
---

import CodeFromFile from "@components/CodeFromFile.astro";

*Need to catch up? Check out [Unit 1: The Lanes](/commodore-amiga/game-01-signal/unit-01).*

## What You're Building

The stage is set, but it's empty. It needs a hero.

By the end of this unit, you'll have:

- A green frog sitting on the start zone
- A hardware sprite driven by the custom chipset
- An understanding of Amiga sprite data structures

No movement yet. Just the frog, waiting for your command.

## Hardware Sprites

The Amiga has 8 hardware sprites (numbered 0-7). They are:

- **16 pixels wide** (always)
- **Any height** (can be as tall as the screen)
- **4 colours each** (from specific palette entries)
- **Independent** of the background (they float on top)

Sprites are handled by **Denise** (display chip) and fetched by **Agnus** (DMA controller). The CPU just points Agnus to the data, and the hardware does the rest.

### Sprite Colour Palette

Each sprite pair uses four consecutive palette entries:

| Sprites | Palette Entries | Registers |
|---------|-----------------|-----------|
| 0-1 | 16-19 | $1A0-$1A6 |
| 2-3 | 20-23 | $1A8-$1AE |
| 4-5 | 24-27 | $1B0-$1B6 |
| 6-7 | 28-31 | $1B8-$1BE |

Entry 16 (for sprites 0-1) is always transparent — it's where you "see through" the sprite. We only set colours 17-19.

## Sprite Data Structure

Sprite data in chip RAM has a specific format:

```
Word 1: VSTART (bits 15-8) | HSTART high 8 bits (bits 7-0)
Word 2: VSTOP (bits 15-8)  | Control bits (bits 7-0)
...
Data:   [Bitplane 0 word] [Bitplane 1 word] per line
...
End:    $0000 $0000 (terminates sprite)
```

### Control Words Explained

The first two words position the sprite:

**Word 1** packs vertical start and horizontal position:
- Bits 15-8: VSTART — first line to display sprite
- Bits 7-0: High 8 bits of horizontal position

**Word 2** defines vertical stop and control flags:
- Bits 15-8: VSTOP — line after last sprite line
- Bit 2: Attach (pairs with next sprite for 16 colours)
- Bit 1: VSTART bit 8 (for positions > 255)
- Bit 0: VSTOP bit 8

For a sprite at Y=180 (hex $B4), 16 lines tall:
- VSTART = $B4
- VSTOP = $C4 (180 + 16 = 196)

### Bitplane Data

After the control words come the actual pixels. Amiga sprites use **planar graphics** — two separate bitplanes that combine to make 4 colours:

| Plane 0 | Plane 1 | Colour |
|---------|---------|--------|
| 0 | 0 | Transparent |
| 1 | 0 | Colour 17 |
| 0 | 1 | Colour 18 |
| 1 | 1 | Colour 19 |

Each line needs two words: bitplane 0, then bitplane 1. For a 16-line sprite, that's 32 words of pixel data, plus the 2 control words, plus 2 end-marker words = 36 words total.

## The Frog Sprite

Here's our 16x16 frog. The bit patterns create a simple rounded shape:

<CodeFromFile src="commodore-amiga/game-01-signal/unit-02/snippets/01-the-frog-sprite.asm" lang="asm" />

The frog starts at line 180 — right in the middle of the start zone.

## Sprite Pointer Registers

The hardware needs to know where sprite data lives in memory. Sprite 0 uses two registers:

| Register | Offset | Purpose |
|----------|--------|---------|
| SPR0PTH | $120 | High word of address |
| SPR0PTL | $122 | Low word of address |

Together they form a 32-bit pointer to the sprite data.

The copper writes 16-bit values, but a chip RAM address needs 32 bits. We could split the address calculation into the copper list, but it's easier to let the CPU poke the address into **placeholder values** in the copper list before the copper runs.

## Setting Up the Sprite

Three things must happen:

1. **Set palette colours** for sprite 0 (entries 17-19)
2. **Write sprite pointer** so hardware knows where data is
3. **Enable sprite DMA** in DMACON

### Adding to the Copper List

We add sprite colours and pointer placeholders at the start of the copper list:

<CodeFromFile src="commodore-amiga/game-01-signal/unit-02/snippets/02-setting-up-the-sprite.asm" lang="asm" />

The `sprpt` label marks where we'll poke the address.

### The CPU Setup Code

Before entering the main loop, the CPU calculates the sprite address and writes it into the copper list:

<CodeFromFile src="commodore-amiga/game-01-signal/unit-02/snippets/03-setting-up-the-sprite.asm" lang="asm" />

The copper list memory looks like:
```
sprpt:   $0120  $????    <- offset 0: reg, offset 2: value (high)
         $0122  $????    <- offset 4: reg, offset 6: value (low)
```

We write to `sprpt+2` (the value after the first register) and `sprpt+6` (the value after the second register). But since we used `lea sprpt+2,a1`, we write to `(a1)` and `4(a1)`.

### Enabling Sprite DMA

Unit 1 used `#$8280` for DMACON (master + copper). Now we add sprite DMA:

<CodeFromFile src="commodore-amiga/game-01-signal/unit-02/snippets/04-setting-up-the-sprite.asm" lang="asm" />

DMACON bits we're setting:
- Bit 15: SET mode (1 = set these bits)
- Bit 9: Master DMA enable
- Bit 8: Bitplane DMA (not needed yet, but harmless)
- Bit 7: Copper DMA
- Bit 5: Sprite DMA

$8320 = %1000001100100000

## Disabling Unused Sprites

There are 8 sprites. If we only use sprite 0, what about sprites 1-7? If we don't set their pointers, they might display garbage from random memory locations.

The safe approach: point unused sprites at an empty sprite structure:

<CodeFromFile src="commodore-amiga/game-01-signal/unit-02/snippets/05-disabling-unused-sprites.asm" lang="asm" />

For now we'll just set sprite 0. The others happen to work because boot memory is zeroed, but we'll handle this properly in a later unit.

## Build It. Run It.

Create or update `hop.asm` with the changes, then:

```bash
vasmm68k_mot -Fhunkexe -kick1hunks -o hop -nosym hop.asm
xdftool hop.adf create + format "Hop" ofs + boot install boot1x + write hop + makedir s
echo "hop" > startup-sequence
xdftool hop.adf write startup-sequence s/startup-sequence
fs-uae --floppy_drive_0=hop.adf
```

You should see the lanes from Unit 1, with a green frog sitting in the start zone!

## What You've Learnt

- **Hardware sprites** are 16 pixels wide, any height, 4 colours each
- **Sprite data format**: 2 control words, interleaved bitplane data, end marker
- **Control words** encode position (VSTART, VSTOP, HSTART)
- **Planar graphics**: two bitplanes combine to make 4 colours
- **Sprite pointers** ($120/$122 for sprite 0) point to chip RAM
- **Copper list patching**: CPU writes addresses into copper instructions
- **DMACON bit 5** enables sprite DMA

## The Complete Code

Here's the full `hop.asm` with the frog sprite:

<CodeFromFile src="commodore-amiga/game-01-signal/unit-02/hop.asm" lang="asm" />

## Recap / Sanity Check

Before moving on, verify:

- [ ] Build succeeds with no errors
- [ ] Disk boots in FS-UAE
- [ ] All colour zones still display correctly
- [ ] Green frog sprite visible in the start zone
- [ ] Frog is positioned roughly centre-left of the start area

## Next Unit

The frog is there, but it's frozen.

In [Unit 3: The Hop](/commodore-amiga/game-01-signal/unit-03), we'll read the joystick and update the sprite position to make the frog move.
